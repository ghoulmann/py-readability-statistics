


	
		9781118494684-bapp01.g.html
		
	
	
		
			
				Appendix
				HDMI Display Modes
				You can use the values in Table 1 and Table 2 with the hdmi_mode option in config.txt to alter the HDMI video output stream. For more information, see Chapter 3, “Configuring the Raspberry Pi".
				Table 1: HDMI Group 1 (CEA)
				
					
						
							
								Value
							
							
								Description
							
						
						
							
								1
							
							
								VGA (640x480)
							
						
						
							
								2
							
							
								480p 60Hz
							
						
						
							
								3
							
							
								480p 60Hz (16:9 aspect ratio)
							
						
						
							
								4
							
							
								720p 60Hz
							
						
						
							
								5
							
							
								1080i 60Hz
							
						
						
							
								6
							
							
								480i 60Hz
							
						
						
							
								7
							
							
								480i 60Hz (16:9 aspect ratio)
							
						
						
							
								8
							
							
								240p 60Hz
							
						
						
							
								9
							
							
								240p 60Hz (16:9 aspect ratio)
							
						
						
							
								10
							
							
								480i 60Hz (Pixel quadrupling enabled)
							
						
						
							
								11
							
							
								480i 60Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								12
							
							
								240p 60Hz (Pixel quadrupling enabled)
							
						
						
							
								13
							
							
								240p 60Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								14
							
							
								480p 60Hz (Pixel doubling enabled)
							
						
						
							
								15
							
							
								480p 60Hz (Pixel doubling enabled) (16:9 aspect ratio)
							
						
						
							
								16
							
							
								1080p 60Hz
							
						
						
							
								17
							
							
								576p 50Hz
							
						
						
							
								18
							
							
								576p 50Hz (16:9 aspect ratio)
							
						
						
							
								19
							
							
								720p 50Hz
							
						
						
							
								20
							
							
								1080i 50Hz
							
						
						
							
								21
							
							
								576i 50Hz
							
						
						
							
								22
							
							
								576i 50Hz (16:9 aspect ratio)
							
						
						
							
								23
							
							
								288p 50Hz
							
						
						
							
								24
							
							
								288p 50Hz (16:9 aspect ratio)
							
						
						
							
								25
							
							
								576i 50Hz (Pixel quadrupling enabled)
							
						
						
							
								26
							
							
								576i 50Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								27
							
							
								288p 50Hz (Pixel quadrupling enabled)
							
						
						
							
								28
							
							
								288p 50Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								29
							
							
								576p 50Hz (Pixel doubling enabled)
							
						
						
							
								30
							
							
								576p 50Hz (Pixel doubling enabled) (16:9 aspect ratio)
							
						
						
							
								31
							
							
								1080p 50Hz
							
						
						
							
								32
							
							
								1080p 24Hz
							
						
						
							
								33
							
							
								1080p 25Hz
							
						
						
							
								34
							
							
								1080p 30Hz
							
						
						
							
								35
							
							
								480p 60Hz (Pixel quadrupling enabled)
							
						
						
							
								36
							
							
								480p 60Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								37
							
							
								576p 50Hz (Pixel quadrupling enabled)
							
						
						
							
								38
							
							
								576p 50Hz (Pixel quadrupling enabled) (16:9 aspect ratio)
							
						
						
							
								39
							
							
								1080i 50Hz (Reduced blanking)
							
						
						
							
								40
							
							
								1080i 100Hz
							
						
						
							
								41
							
							
								720p 100Hz
							
						
						
							
								42
							
							
								576p 100Hz
							
						
						
							
								43
							
							
								576p 100Hz (16:9 aspect ratio)
							
						
						
							
								44
							
							
								576i 100Hz
							
						
						
							
								45
							
							
								576i 100Hz (16:9 aspect ratio)
							
						
						
							
								46
							
							
								1080i 120Hz
							
						
						
							
								47
							
							
								720p 120Hz
							
						
						
							
								48
							
							
								480p 120Hz
							
						
						
							
								49
							
							
								480p 120Hz (16:9 aspect ratio)
							
						
						
							
								50
							
							
								480i 120Hz
							
						
						
							
								51
							
							
								480i 120Hz (16:9 aspect ratio)
							
						
						
							
								52
							
							
								576p 200Hz
							
						
						
							
								53
							
							
								576p 200Hz (16:9 aspect ratio)
							
						
						
							
								54
							
							
								576i 200Hz
							
						
						
							
								55
							
							
								576i 200Hz (16:9 aspect ratio)
							
						
						
							
								56
							
							
								480p 24Hz0
							
						
						
							
								57
							
							
								480p 24Hz0 (16:9 aspect ratio)
							
						
						
							
								58
							
							
								480i 240Hz
							
						
						
							
								59
							
							
								480i 240Hz (16:9 aspect ratio)
							
						
					
				
				Table 2: HDMI Group 2 (DMT)
				
					
						
							
								Value
							
							
								Description
							
						
						
							
								1
							
							
								640×350 85Hz
							
						
						
							
								2
							
							
								640×400 85Hz
							
						
						
							
								3
							
							
								720×400 85Hz
							
						
						
							
								4
							
							
								640×480 60Hz
							
						
						
							
								5
							
							
								640×480 72Hz
							
						
						
							
								6
							
							
								640×480 75Hz
							
						
						
							
								7
							
							
								640×480 85Hz
							
						
						
							
								8
							
							
								800×600 56Hz
							
						
						
							
								9
							
							
								800×600 60Hz
							
						
						
							
								10
							
							
								800×600 72Hz
							
						
						
							
								11
							
							
								800×600 75Hz
							
						
						
							
								12
							
							
								800×600 85Hz
							
						
						
							
								13
							
							
								800×600 120Hz
							
						
						
							
								14
							
							
								848×480 60Hz
							
						
						
							
								15
							
							
								1024×768 43Hz, incompatible with the Raspberry Pi
							
						
						
							
								16
							
							
								1024×768 60Hz
							
						
						
							
								17
							
							
								1024×768 70Hz
							
						
						
							
								18
							
							
								1024×768 75Hz
							
						
						
							
								19
							
							
								1024×768 85Hz
							
						
						
							
								20
							
							
								1024×768 120Hz
							
						
						
							
								21
							
							
								1152×864 75Hz
							
						
						
							
								22
							
							
								1280×768 (Reduced blanking)
							
						
						
							
								23
							
							
								1280×768 60Hz
							
						
						
							
								24
							
							
								1280×768 75Hz
							
						
						
							
								25
							
							
								1280×768 85Hz
							
						
						
							
								26
							
							
								1280×768 120Hz (Reduced blanking)
							
						
						
							
								27
							
							
								1280×800 (Reduced blanking)
							
						
						
							
								28
							
							
								1280×800 60Hz
							
						
						
							
								29
							
							
								1280×800 75Hz
							
						
						
							
								30
							
							
								1280×800 85Hz
							
						
						
							
								31
							
							
								1280×800 120Hz (Reduced blanking)
							
						
						
							
								32
							
							
								1280×960 60Hz
							
						
						
							
								33
							
							
								1280×960 85Hz
							
						
						
							
								34
							
							
								1280×960 120Hz (Reduced blanking)
							
						
						
							
								35
							
							
								1280×1024 60Hz
							
						
						
							
								36
							
							
								1280×1024 75Hz
							
						
						
							
								37
							
							
								1280×1024 85Hz
							
						
						
							
								38
							
							
								1280×1024 120Hz (Reduced blanking)
							
						
						
							
								39
							
							
								1360×768 60Hz
							
						
						
							
								40
							
							
								1360×768 120Hz (Reduced blanking)
							
						
						
							
								41
							
							
								1400×1050 (Reduced blanking)
							
						
						
							
								42
							
							
								1400×1050 60Hz
							
						
						
							
								43
							
							
								1400×1050 75Hz
							
						
						
							
								44
							
							
								1400×1050 85Hz
							
						
						
							
								45
							
							
								1400×1050 120Hz (Reduced blanking)
							
						
						
							
								46
							
							
								1440×900 (Reduced blanking)
							
						
						
							
								47
							
							
								1440×900 60Hz
							
						
						
							
								48
							
							
								1440×900 75Hz
							
						
						
							
								49
							
							
								1440×900 85Hz
							
						
						
							
								50
							
							
								1440×900 120Hz (Reduced blanking)
							
						
						
							
								51
							
							
								1600×1200 60Hz
							
						
						
							
								52
							
							
								1600×1200 65Hz
							
						
						
							
								53
							
							
								1600×1200 70Hz
							
						
						
							
								54
							
							
								1600×1200 75Hz
							
						
						
							
								55
							
							
								1600×1200 85Hz
							
						
						
							
								56
							
							
								1600×1200 120Hz (Reduced blanking)
							
						
						
							
								57
							
							
								1680×1050 (Reduced blanking)
							
						
						
							
								58
							
							
								1680×1050 60Hz
							
						
						
							
								59
							
							
								1680×1050 75Hz
							
						
						
							
								60
							
							
								1680×1050 85Hz
							
						
						
							
								61
							
							
								1680×1050 120Hz (Reduced blanking)
							
						
						
							
								62
							
							
								1792×1344 60Hz
							
						
						
							
								63
							
							
								1792×1344 75Hz
							
						
						
							
								64
							
							
								1792×1344 120Hz (Reduced blanking)
							
						
						
							
								65
							
							
								1856×1392 60Hz
							
						
						
							
								66
							
							
								1856×1392 75Hz
							
						
						
							
								67
							
							
								1856×1392 120Hz (Reduced blanking)
							
						
						
							
								68
							
							
								1920×1200 (Reduced blanking)
							
						
						
							
								69
							
							
								1920×1200 60Hz
							
						
						
							
								70
							
							
								1920×1200 75Hz
							
						
						
							
								71
							
							
								1920×1200 85Hz
							
						
						
							
								72
							
							
								1920×1200 120Hz (Reduced blanking)
							
						
						
							
								73
							
							
								1920×1440 60Hz
							
						
						
							
								74
							
							
								1920×1440 75Hz
							
						
						
							
								75
							
							
								1920×1440 120Hz (Reduced blanking)
							
						
						
							
								76
							
							
								2560×1600 (Reduced blanking)
							
						
						
							
								77
							
							
								2560×1600 60Hz
							
						
						
							
								78
							
							
								2560×1600 75Hz
							
						
						
							
								79
							
							
								2560×1600 85Hz
							
						
						
							
								80
							
							
								2560×1600 120Hz (Reduced blanking)
							
						
						
							
								81
							
							
								1366×768 60Hz
							
						
						
							
								82
							
							
								1920×1080 (1080p) 60Hz
							
						
						
							
								83
							
							
								1600×900 (Reduced blanking)
							
						
						
							
								84
							
							
								2048×1152 (Reduced blanking)
							
						
						
							
								85
							
							
								1280×720 (720p) 60Hz
							
						
						
							
								86
							
							
								1366×768 (Reduced blanking)
							
						
					
				
				
				
			
		
	




	
		9781118494684-ch01.g.html
		
	
	
		
			
				Chapter 1
				Meet the Raspberry Pi
				Your Raspberry Pi board is a miniature marvel, packing considerable computing power into a footprint no larger than a credit card. It’s capable of some amazing things, but there are a few things you’re going to need to know before you plunge head-first into the bramble patch.
				
				If you’re eager to get started, skip ahead a couple of pages to find out how to connect your Raspberry Pi to a display, keyboard and mouse.
				ARM vs. x86
				The processor at the heart of the Raspberry Pi system is a Broadcom BCM2835 system-on-chip (SoC) multimedia processor. This means that the vast majority of the system’s components, including its central and graphics processing units along with the audio and communications hardware, are built onto that single component hidden beneath the 256 MB memory chip at the centre of the board (see Figure 1-1).
				
					Figure 1-1: The BCM2835 SoC, located beneath a Hynix memory chip
				
				
				It’s not just this SoC design that makes the BCM2835 different to the processor found in your desktop or laptop, however. It also uses a different instruction set architecture (ISA), known as ARM.
				Developed by Acorn Computers back in the late eighties, the ARM architecture is a relatively uncommon sight in the desktop world. Where it excels, however, is in mobile devices: the phone in your pocket almost certainly has at least one ARM-based processing core hidden away inside. Its combination of a simple reduced instruction set (RISC) architecture and low power draw make it the perfect choice over desktop chips with high power demands and complex instruction set (CISC) architectures.
				The ARM-based BCM2835 is the secret of how the Raspberry Pi is able to operate on just the 5V 1A power supply provided by the onboard micro-USB port. It’s also the reason why you won’t find any heat-sinks on the device: the chip’s low power draw directly translates into very little waste heat, even during complicated processing tasks.
				It does, however, mean that the Raspberry Pi isn’t compatible with traditional PC software. The majority of software for desktops and laptops is built with the x86 instruction set architecture in mind, as found in processors from the likes of AMD, Intel and VIA. As a result, it won’t run on the ARM-based Raspberry Pi.
				The BCM2835 uses a generation of ARM’s processor design known as ARM11, which in turn is designed around a version of the instruction set architecture known as ARMv6. This is worth remembering: ARMv6 is a lightweight and powerful architecture, but has a rival in the more advanced ARMv7 architecture used by the ARM Cortex family of processors. Software developed for ARMv7, like software developed for x86, is sadly not compatible with the Raspberry Pi’s BCM2835—although developers can usually convert the software to make it suitable.
				That’s not to say you’re going to be restricted in your choices. As you’ll discover later in the book, there is plenty of software available for the ARMv6 instruction set, and as the Raspberry Pi’s popularity continues to grow, that will only increase. In this book, you’ll also learn how to create your own software for the Pi even if you have no experience with programming.
				Windows vs. Linux
				Another important difference between the Raspberry Pi and your desktop or laptop, other than the size and price, is the operating system—the software that allows you to control the computer.
				The majority of desktop and laptop computers available today run one of two operating systems: Microsoft Windows or Apple OS X. Both platforms are closed source, created in a secretive environment using proprietary techniques.
				These operating systems are known as closed source for the nature of their source code, the computer-language recipe that tells the system what to do. In closed-source software, this recipe is kept a closely-guarded secret. Users are able to obtain the finished software, but never to see how it’s made.
				The Raspberry Pi, by contrast, is designed to run an operating system called GNU/Linux—hereafter referred to simply as Linux. Unlike Windows or OS X, Linux is open source: it’s possible to download the source code for the entire operating system and make whatever changes you desire. Nothing is hidden, and all changes are made in full view of the public. This open source development ethos has allowed Linux to be quickly altered to run on the Raspberry Pi, a process known as porting. At the time of this writing, several versions of Linux—known as distributions—have been ported to the Raspberry Pi’s BCM2835 chip, including Debian, Fedora Remix and Arch Linux.
				The different distributions cater to different needs, but they all have something in common: they’re all open source. They’re also all, by and large, compatible with each other: software written on a Debian system will operate perfectly well on Arch Linux and vice versa.
				Linux isn’t exclusive to the Raspberry Pi. Hundreds of different distributions are available for desktops, laptops and even mobile devices; and Google’s popular Android platform is developed on top of a Linux core. If you find that you enjoy the experience of using Linux on the Raspberry Pi, you could consider adding it to other computing devices you use as well. It will happily coexist with your current operating system, allowing you to enjoy the benefits of both while giving you a familiar environment when your Pi is unavailable.
				As with the difference between ARM and x86, there’s a key point to make about the practical difference between Windows, OS X and Linux: software written for Windows or OS X won’t run on Linux. Thankfully, there are plenty of compatible alternatives for the overwhelming majority of common software products—better still, the majority are free to use and as open source as the operating system itself.
				Getting Started with the Raspberry Pi
				Now that you have a basic understanding of how the Pi differs from other computing devices, it’s time to get started. If you’ve just received your Pi, take it out of its protective anti-static bag and place it on a flat, non-conductive surface before continuing with this chapter.
				Connecting a Display
				Before you can start using your Raspberry Pi, you’re going to need to connect a display. The Pi supports three different video outputs: composite video, HDMI video and DSI video. Composite video and HDMI video are readily accessible to the end-user, as described in this section, while DSI video requires some specialised hardware.
				Composite Video
				Composite video, available via the yellow-and-silver port at the top of the Pi known as an RCA phono connector (see Figure 1-2), is designed for connecting the Raspberry Pi to older display devices. As the name suggests, the connector creates a composite of the colours found within an image—red, green and blue—and sends it down a single wire to the display device, typically an old cathode-ray tube (CRT) TV.
				
					Figure 1-2: The yellow RCA phono connector, for composite video output
				
				
				When no other display device is available, a composite video connection will get you started with the Pi. The quality, however, isn’t great. Composite video connections are significantly more prone to interference, lack clarity and run at a limited resolution, meaning that you can fit fewer icons and lines of text on the screen at once.
				HDMI Video
				A better-quality picture can be obtained using the HDMI (High Definition Multimedia Interface) connector, the only port found on the bottom of the Pi (see Figure 1-3). Unlike the analogue composite connection, the HDMI port provides a high-speed digital connection for pixel-perfect pictures on both computer monitors and high-definition TV sets. Using the HDMI port, a Pi can display images at the Full HD 1920x1080 resolution of most modern HDTV sets. At this resolution, significantly more detail is available on the screen.
				
					Figure 1-3: The silver HDMI connector, for high-definition video output
				
				
				If you’re hoping to use the Pi with an existing computer monitor, you may find that your display doesn’t have an HDMI input. That’s not a disaster: the digital signals present on the HDMI cable map to a common computer monitor standard called DVI (Digital Video Interconnect). By purchasing an HDMI-to-DVI cable, you’ll be able to connect the Pi’s HDMI port to a monitor with DVI-D connectivity.
				If your monitor has a VGA input—a D-shaped connector with 15 pins, typically coloured silver and blue—the Raspberry Pi can’t connect to it. Adapters are available that will take in a digital DVI signal and convert it to an analogue VGA signal, but these are expensive and bulky. The best option here is simply to buy a more-modern monitor with a DVI or HDMI input.
				DSI Video
				The final video output on the Pi can be found above the SD card slot on the top of the printed circuit board— it’s a small ribbon connector protected by a layer of plastic. This is for a video standard known as Display Serial Interface (DSI), which is used in the flat-panel displays of tablets and smartphones. Displays with a DSI connector are rarely available for retail purchase, and are typically reserved for engineers looking to create a compact, self-contained system. A DSI display can be connected by inserting a ribbon cable into the matched connector on the Pi, but for beginners, the use of a composite or HDMI display is recommended.
				Connecting Audio
				If you’re using the Raspberry Pi’s HDMI port, audio is simple: when properly configured, the HDMI port carries both the video signal and a digital audio signal. This means that you can connect a single cable to your display device to enjoy both sound and pictures.
				Assuming you’re connecting the Pi to a standard HDMI display, there’s very little to do at this point. For now, it’s enough to simply connect the cable.
				If you’re using the Pi with a DVI-D monitor via an adapter or cable, audio will not be included. This highlights the main difference between HDMI and DVI: while HDMI can carry audio signals, DVI cannot.
				For those with DVI-D monitors, or those using the composite video output, a black 3.5 mm audio jack located on the top edge of the Pi next to the yellow phono connector provides analogue audio (see Figure 1-2). This is the same connector used for headphones and microphones on consumer audio equipment, and it’s wired in exactly the same way. If you want, you can simply connect a pair of headphones to this port for quick access to audio.
				
				While headphones can be connected directly to the Raspberry Pi, you may find the volume a little lacking. If possible, connect a pair of powered speakers instead. The amplifier inside will help boost the signal to a more audible level.
				If you’re looking for something more permanent, you can either use standard PC speakers that have a 3.5 mm connector or you can buy some adapter cables. For composite video users, a 3.5 mm to RCA phono cable is useful. This provides the two white-and-red RCA phono connections that sit alongside the video connection, each carrying a channel of the stereo audio signal to the TV.
				For those connecting the Pi to an amplifier or stereo system, you’ll either need a 3.5 mm to RCA phono cable or a 3.5 mm to 3.5 mm cable, depending on what spare connections you have on your system. Both cable types are readily and cheaply available at consumer electronics shops, or can be purchased even cheaper at online retailers such as Amazon.
				Connecting a Keyboard and Mouse
				Now that you’ve got your Raspberry Pi’s output devices sorted, it’s time to think about input. As a bare minimum, you’re going to need a keyboard, and for the majority of users, a mouse or trackball is a necessity too.
				First, some bad news: if you’ve got a keyboard and mouse with a PS/2 connector—a round plug with a horseshoe-shaped array of pins—then you’re going to have to go out and buy a replacement. The old PS/2 connection has been superseded, and the Pi expects your peripherals to be connected over the Universal Serial Bus (USB) port.
				Depending on whether you purchased the Model A or Model B, you’ll have either one or two USB ports available on the right-hand side of the Pi (see Figure 1-4). If you’re using Model B, you can connect the keyboard and mouse directly to these ports. If you’re using Model A, you’ll need to purchase a USB hub in order to connect two USB devices simultaneously.
				
					Figure 1-4: Model B’s two USB ports
				
				
				A USB hub is a good investment for any Pi user: even if you’ve got a Model B, you’ll use up both your available ports just connecting your keyboard and mouse, leaving nothing free for additional devices such as an external optical drive, storage device or joystick. Make sure you buy a powered USB hub: passive models are cheaper and smaller, but lack the ability to run current-hungry devices like CD drives and external hard drives.
				
				If you want to reduce the number of power sockets in use, connect the Raspberry Pi’s USB power lead to your powered USB hub. This way, the Pi can draw its power directly from the hub, rather than needing its own dedicated power socket and mains adapter. This will only work on hubs with a power supply capable of providing 700mA to the Pi’s USB port, along with whatever power is required by other peripherals.
				Connecting the keyboard and mouse is as simple as plugging them in to the USB ports, either directly in the case of a Model B or via a USB hub in the case of a Model A.
				
				A Note on Storage
				As you’ve probably noticed, the Raspberry Pi doesn’t have a traditional hard drive. Instead it uses a Secure Digital (SD) memory card, a solid-state storage system typically used in digital cameras. Almost any SD card will work with the Raspberry Pi, but because it holds the entire operating system, it is necessary for the card to be at least 2 GB in capacity to store all the required files.
				SD cards with the operating system preloaded are available from the official Raspberry Pi Store along with numerous other sites on the Internet. If you’ve purchased one of these, or received it in a bundle with your Pi, you can simply plug it in to the SD card slot on the bottom side of the left-hand edge. If not, you’ll need to install an operating system—known as flashing—onto the card before it’s ready to go.
				Some SD cards work better than others, with some models refusing to work at all with the Raspberry Pi. For an up-to-date list of SD card models known to work with the Pi, visit the eLinux Wiki page: http://www.elinux.org/RPi_VerifiedPeripherals#SD_cards
				
				Flashing the SD Card
				To prepare a blank SD card for use with the Raspberry Pi, you’ll need to flash an operating system onto the card. While this is slightly more complicated than simply dragging and dropping files onto the card, it shouldn’t take more than a few minutes to complete.
				Firstly, you’ll need to decide which Linux distribution you would like to use with your Raspberry Pi. Each has its advantages and disadvantages. Don’t worry if you change your mind later and want to try a different version of Linux: an SD card can be flashed again with a new operating system at any point.
				The most up-to-date list of Linux releases compatible with the Pi is available from the Raspberry Pi website at http://www.raspberrypi.org/downloads. 
				The Foundation provides BitTorrent links for each distribution. These are small files that can be used with BitTorrent software to download the files from other users. Using these links is an efficient and fast way to distribute large files, and keeps the Foundation’s download servers from becoming overloaded.
				To use a BitTorrent link, you’ll need to have a compatible client installed. If you don’t already have a BitTorrent client installed, download one and install it before trying to download the Raspberry Pi Linux distribution. One client for Windows, OS X and Linux is µTorrent, available from http://www.utorrent.com/downloads.
				Which distribution you choose to download is up to you. Instructions in the rest of the book will be based on the Debian Raspberry Pi distribution, a good choice for beginners. Where possible, we’ll give you instructions for other distributions as well.
				Linux distributions for the Raspberry Pi are provided as a single image file, compressed to make it faster to download. Once you’ve downloaded the Zip archive (a compressed file, which takes less time to download than the uncompressed files would) for your chosen distribution, you’ll need to decompress it somewhere on your system. In most operating systems, you can simply double-click the file to open it, and then choose Extract or Unzip to retrieve the contents.
				After you’ve decompressed the archive, you’ll end up with two separate files. The file ending in sha1 is a hash, which can be used to verify that the download hasn’t been corrupted in transit. The file ending in img contains an exact copy of an SD card set up by the distribution’s creators in a way that the Raspberry Pi understands. This is the file that needs to be flashed to the SD card.
				
				During the following, you’ll be using a software utility called dd. Used incorrectly dd will happily write the image to your main hard drive, erasing your operating system and all your stored data. Make sure you read the instructions in each section thoroughly and note the device address of your SD card carefully. Read twice, write once!
				Flashing from Linux
				If your current PC is running a variant of Linux already, you can use the dd command to write the contents of the image file out to the SD card. This is a text-interface program operated from the command prompt, known as a terminal in Linux parlance. Follow these steps to flash the SD card:
					1.	Open a terminal from your distribution’s applications menu.
					2.	Plug your blank SD card into a card reader connected to the PC.
					3.	Type sudo fdisk -l to see a list of disks. Find the SD card by its size, and note the device address (/dev/sdX, where X is a letter identifying the storage device. Some systems with integrated SD card readers may use the alternative format /dev/mmcblkX—if this is the case, remember to change the target in the following instructions accordingly).
					4.	Use cd to change to the directory with the .img file you extracted from the Zip archive.
					5.	Type sudo dd if=imagefilename.img of=/dev/sdX bs=2M to write the file imagefilename.img to the SD card connected to the device address from step 3. Replace imagefilename.img with the actual name of the file extracted from the Zip archive. This step takes a while, so be patient! During flashing, nothing will be shown on the screen until the process is fully complete (see Figure 1-5).
				
					Figure 1-5: Flashing the SD card using the dd command in Linux
				
				
				Flashing from OS X
				If your current PC is a Mac running Apple OS X, you’ll be pleased to hear that things are as simple as with Linux. Thanks to a similar ancestry, OS X and Linux both contain the dd utility, which you can use to flash the system image to your blank SD card as follows:
					1.	Select Utilities from the Application menu, and then click on the Terminal application.
					2.	Plug your blank SD card into a card reader connected to the Mac.
					3.	Type diskutil list to see a list of disks. Find the SD card by its size, and note the device address (/dev/diskX, where X is a letter identifying the storage device).
					4.	If the SD card has been automatically mounted and is displayed on the desktop, type diskutil unmountdisk /dev/diskX to unmount it before proceeding.
					5.	Use cd to change to the directory with the .img file you extracted from the Zip archive.
					6.	Type dd if=imagefilename.img of=/dev/diskX bs=2M to write the file imagefilename.img to the SD card connected to the device address from step 3. Replace imagefilename.img with the actual name of the file extracted from the Zip archive. This step takes a while, so be patient!
				Flashing from Windows
				If your current PC is running Windows, things are slightly trickier than with Linux or OS X. Windows does not have a utility like dd, so some third-party software is required to get the image file flashed onto the SD card. Although it’s possible to install a Windows-compatible version of dd, there is an easier way: the Image Writer for Windows. Designed specifically for creating USB or SD card images of Linux distributions, it features a simple graphical user interface that makes the creation of a Raspberry Pi SD card straightforward.
				The latest version of Image Writer for Windows can be found at the official website: https://launchpad.net/win32-image-writer. Follow these steps to download, install and use the Image Writer for Windows software to prepare the SD card for the Pi:
					1.	Download the binary (not source) Image Writer for Windows Zip file, and extract it to a folder on your computer.
					2.	Plug your blank SD card into a card reader connected to the PC.
					3.	Double-click the Win32DiskImager.exe file to open the program, and click the blue folder icon to open a file browse dialogue box.
					4.	Browse to the imagefilename.img file you extracted from the distribution archive, replacing imagefilename.img with the actual name of the file extracted from the Zip archive, and then click the Open button.
					5.	Select the drive letter corresponding to the SD card from the Device drop-down dialogue box. If you’re unsure which drive letter to choose, open My Computer or Windows Explorer to check.
					6.	Click the Write button to flash the image file to the SD card. This process takes a while, so be patient!
				
				No matter which operating system you’re writing from, it’s important to ensure you leave the SD card connected until the image has been completely written. If you don’t, you may find that Pi doesn’t boot when the SD card is connected. If this happens, start the process again.
				When the image has been flashed onto the SD card, remove it from the computer and insert it into the Raspberry Pi’s SD card slot, located underneath the circuit board. The SD card should be inserted with the label facing away from the board and pushed fully home to ensure a good connection.
				Connecting External Storage
				While the Raspberry Pi uses an SD card for its main storage device—known as a boot device—you may find that you run into space limitations quite quickly. Although large SD cards holding 32 GB, 64 GB or more are available, they are often prohibitively expensive.
				Thankfully, there are devices that provide an additional hard drive to any computer when connected via a USB cable. Known as USB Mass Storage (UMS) devices, these can be physical hard drives, solid-state drives (SSDs) or even portable pocket-sized flash drives (see Figure 1-6).
				
					Figure 1-6: Two USB Mass Storage devices: a pen drive and an external hard drive
				
				
				The majority of USB Mass Storage devices can be read by the Pi, whether or not they have existing content. In order for the Pi to be able to access these devices, their drives must be mounted—a process you will learn in Chapter 2, “Linux System Administration". For now, it’s enough to connect the drives to the Pi in readiness.
				Connecting the Network
				While the majority of these setup instructions are equally applicable to both the Raspberry Pi Model A and the Model B, networking is a special exception. To keep the component count—and therefore the cost—as low as possible, the Model A doesn’t feature any onboard networking. Thankfully, that doesn’t mean you can’t network the Model A; only that you’ll need some additional equipment to do so.
				
				Networking the Model A
				To give the Model A the same networking capabilities as its more expensive Model B counterpart, you’ll need a USB-connected Ethernet adapter. This connects to a free USB port on the Raspberry Pi or a connected hub and provides a wired Ethernet connection with an RJ45 connector, the same as is available on the Model B.
				A 10/100 USB Ethernet adapter—with the numbers referring to its two-speed mode, 10 Mb/s and 100 Mb/s—can be purchased from online retailers for very little money. When buying an Ethernet adapter, be sure to check that Linux is listed as a supported operating system. A few models only work with Microsoft Windows, and are incompatible with the Raspberry Pi.
				Don’t be tempted to go for a gigabit-class adapter, which will be referred to as a 10/100/1000 USB Ethernet adapter. Standard USB ports, as used on the Raspberry Pi, can’t cope with the speed of a gigabit Ethernet connection, and you’ll see no benefit to the more expensive adapter.
				
				Wired Networking
				To get your Raspberry Pi on the network, you’ll need to connect an RJ45 Ethernet patch cable between the Pi and a switch, router or hub. If you don’t have a router or hub, you can get your desktop or laptop talking to the Pi by connecting the two directly together with a patch cable.
				Usually, connecting two network clients together in this way requires a special cable, known as a crossover cable. In a crossover cable, the receive and transmit pairs are swapped so that the two devices are prevented from talking over each other—a task usually handled by a network switch or hub.
				The Raspberry Pi is cleverer than that, however. The RJ45 port on the side of the Pi (see Figure 1-7) includes a feature known as auto-MDI, which allows it to reconfigure itself automatically. As a result, you can use any RJ45 cable—crossover or not—to connect the Pi to the network, and it will adjust its configuration accordingly.
				
					Figure 1-7: The Raspberry Pi Model B’s Ethernet port
				
				
				If you do connect the Pi directly to a PC or laptop, you won’t be able to connect out onto the Internet by default. To do so, you’ll need to configure your PC to bridge the wired Ethernet port and another (typically wireless) connection. Doing so is outside the scope of this book, but if you are completely unable to connect the Pi to the Internet in any other way, you can try searching your operating system’s help file for “bridge network" to find more guidance.
				With a cable connected, the Pi will automatically receive the details it needs to access the Internet when it loads its operating system through the Dynamic Host Configuration Protocol (DHCP). This assigns the Pi an Internet Protocol (IP) address on your network, and tells it the gateway it needs to use to access the Internet (typically the IP address of your router or modem).
				For some networks, there is no DHCP server to provide the Pi with an IP address. When connected to such a network, the Pi will need manual configuration. You’ll learn more about this in Chapter 4, “Network Configuration".
				Wireless Networking
				Current Raspberry Pi models don’t feature any form of wireless network capability onboard, but—as with adding wired Ethernet to the Model A—it’s possible to add Wi-Fi support to any Pi using a USB wireless adapter (see Figure 1-8).
				
					Figure 1-8: Two USB wireless adapters, suitable for use with the Raspberry Pi
				
				
				Using such a device, the Pi can connect to a wide range of wireless networks, including those running on the latest 802.11n high-speed standard. Before purchasing a USB wireless adapter, check the following:
				Ensure that Linux is listed as a supported operating system. Some wireless adapters are provided with drivers for Windows and OS X only, making them incompatible with the Raspberry Pi. A list of Wi-Fi adapters known to work with the Raspberry Pi can be found on the following website: http://elinux.org/RPi_VerifiedPeripherals#USB_WiFi_Adapters
				Ensure that your Wi-Fi network type is supported by the USB wireless adapter. The network type will be listed in the specifications as a number followed by a letter. If your network type is 802.11a, for example, an 802.11g wireless adapter won’t work.
				Check the frequencies supported by the card. Some wireless network standards, like 802.11a, support more than one frequency. If a USB wireless adapter is designed to work on a 2.4GHz network, it won’t connect to a 5GHz network.
				Check the encryption type used by your wireless network. Most modern USB wireless adapters support all forms of encryption, but if you’re buying a second-hand or older model, you may find it won’t connect to your network. Common encryption types include the outdated WEP and more modern WPA and WPA2.
				Configuration of the wireless connection is done within Linux, so for now it’s enough to simply connect the adapter to the Pi (ideally through a powered USB hub.) You’ll learn how to configure the connection in Chapter 4, “Network Configuration".
				Connecting Power
				The Raspberry Pi is powered by the small micro-USB connector found on the lower left side of the circuit board. This connector is the same as found on the majority of smartphones and some tablet devices.
				Many chargers designed for smartphones will work with the Raspberry Pi, but not all. The Pi is more power-hungry than most micro-USB devices, and requires up to 700mA in order to operate. Some chargers can only supply up to 500mA, causing intermittent problems in the Pi’s operation (see Chapter 3, “Troubleshooting").
				Connecting the Pi to the USB port on a desktop or laptop computer is possible, but not recommended. As with smaller chargers, the USB ports on a computer can’t provide the power required for the Pi to work properly.
				Only connect the micro-USB power supply when you are ready to start using the Pi. With no power button on the device, it will start working the instant power is connected and can only be turned off again by physically removing the power cable.
				
				
			
		
	




	
		9781118494684-ch02.g.html
		
	
	
		
			
				Chapter 2
				Linux System Administration
				The majority of modern Linux distributions are user-friendly, with a graphical user interface (GUI) that provides an easy way to perform common tasks. It is, however, quite different to both Windows and OS X, so if you’re going to get the most out of your Raspberry Pi, you’ll need a quick primer in using the operating system.
				Linux: An Overview
				As briefly explained in Chapter 1, “Meet the Raspberry Pi", Linux is an open-source project which was originally founded to produce a kernel that would be free for anyone to use. The kernel is the heart of an operating system, and handles the communication between the user and the hardware.
				Although only the kernel itself is rightly called Linux, the term is often used to refer to a collection of different open-source projects from a variety of companies. These collections come together to form different flavours of Linux, known as distributions.
				The original version of Linux was combined with a collection of tools created by a group called GNU. The resulting system, known as GNU/Linux, was basic but powerful. Unlike other operating systems of the era, it offered facilities like multiple user accounts where several users can share a single computer. That’s something rival closed-source operating systems have taken on board, with both Windows and OS X now supporting multiple user accounts on the same system. It’s also still present in Linux, and provides security and protection for the operating system.
				In Linux, you’ll spend most of your time running a restricted user account. This doesn’t mean you’re being limited in what you can do. Instead, it prevents you from accidentally doing something that will break the software on your Raspberry Pi. It also prevents viruses and other malware from infecting the system by locking down access to critical system files and directories.
				Before you can get started, it’s worth becoming familiar with some of the terms and concepts used in the world of Linux, as defined in Table 2-1. Even if you’re experienced with other operating systems, it’s a good idea to review this table before booting up your Pi for the first time.
				Table 2-1 The Quick Linux Glossary
				
					
						
							
								Term/Concept
							
							
								Definition
							
						
						
							
								Bash
							
							
								The most popular shell choice, used in the majority of Linux distributions.
							
						
						
							
								Bootloader
							
							
								Software responsible for loading the Linux kernel. The most common is GRUB.
							
						
						
							
								Console
							
							
								A version of the terminal which is always available, and the first thing you see on the Pi.
							
						
						
							
								Desktop environment
							
							
								Software to make the GUI look pretty. GNOME and KDE are popular desktop environments.
							
						
						
							
								Directory
							
							
								The Linux term for what Windows calls folders, where files are stored.
							
						
						
							
								Distribution
							
							
								A particular version of Linux. Fedora Remix, Arch and Debian are distributions.
							
						
						
							
								Executable
							
							
								A file that can be run as a program. Linux files must be marked executable in order to run.
							
						
						
							
								EXT2/3/4
							
							
								The EXTended file system, the most common format used in Linux.
							
						
						
							
								File system
							
							
								The way a hard drive or other storage device is formatted so it’s ready for file storage.
							
						
						
							
								GNOME
							
							
								One of the most common Linux desktop environments around.
							
						
						
							
								GNU
							
							
								A free software project, which provides many of the tools used in Linux distributions.
							
						
						
							
								GRUB
							
							
								The GRand Unified Bootloader, created by GNU and used to load the Linux kernel.
							
						
						
							
								GUI
							
							
								A graphical user interface, in which the user operates the computer via a mouse or touch.
							
						
						
							
								KDE
							
							
								Another extremely popular Linux desktop environment.
							
						
						
							
								Linux
							
							
								Properly, the kernel used by GNU/Linux. Popularly, an open-source operating system.
							
						
						
							
								Live CD
							
							
								A Linux distribution provided as a CD or DVD, which doesn’t require installation.
							
						
						
							
								Package
							
							
								A collection of files required to run an application, typically handled by the package manager.
							
						
						
							
								Package manager
							
							
								A tool for keeping track of, and installing new, software.
							
						
						
							
								Partition
							
							
								A section of a hard drive which is ready to have a file system applied to it for storage.
							
						
						
							
								Root
							
							
								The main user account in Linux, equivalent to the Windows administrator account.
							
						
						
							
								Shell
							
							
								A text-based command prompt, loaded in a terminal.
							
						
						
							
								sudo
							
							
								A program that allows restricted users to run a command as the root user.
							
						
						
							
								Superuser
							
							
								See Root.
							
						
						
							
								Terminal
							
							
								A text-based command prompt in which the user interacts with a shell program.
							
						
						
							
								X11
							
							
								The X Window system, a package that provides a graphical user interface (GUI).
							
						
					
				
				
				The Terminal and the GUI
				As in OS X and Windows, there are typically two main ways to achieve a given goal in Linux: through the graphical user interface (GUI) and through the command line (known in Linux parlance as the console or the terminal).
				The appearance of various Linux distributions can be quite different, depending on the desktop environment in use. In this book, the recommended Debian distribution is used, but most of the commands you will be learning are entered at the terminal and are typically the same across all distributions.
				Where other distributions differ, you will be given alternative methods of achieving the same goals.
				
				Linux Basics
				Although there are hundreds of different Linux distributions available, they all share a common set of tools. These tools, which are operated via the terminal, are analogous to similar tools on Windows and OS X. To get started, you’ll need to learn the following commands:
				ls—Short for listing, ls provides a list of the contents of the current directory. Alternatively, it can be called with an argument of the directory to be listed. As an example, typing ls /home will provide a list of the contents of /home, regardless of your current directory. The Windows equivalent is dir.
				cd—An initialism of change directory, cd allows you to navigate your way through the file system. Typing cd on its own puts you back in your home directory. Typing the command along with the name of the directory you wish to move to, by contrast, switches to that directory. Note that directories can be absolute or relative: cd boot will move you to the directory called boot under your current directory, but cd /boot will move you straight to the /boot directory wherever you are.
				mv—The move command has two purposes in Linux: it allows a file to be moved from one directory to another, and it also allows files to be renamed. That latter feature may seem out of place, but in Linux terms, the file is being moved from one name to another. The command is called as mv oldfile newfile.
				rm—Short for remove, rm deletes files. Any file—or list of files—provided after the command name will be deleted. The Windows equivalent is del, and the two share a common requirement that care should be taken to ensure the right file is deleted.
				rmdir—By itself, rm cannot usually remove directories. As a result, rmdir is provided to delete directories once they have been emptied of files by rm.
				mkdir—The opposite of rmdir, the mkdir command creates new directories. For example, typing mkdir myfolder at the terminal will create a new directory called myfolder under the current working directory. As with cd, directories provided to the command can be relative or absolute.
				Introducing Debian
				Debian is one of the oldest Linux distributions around, and a great choice for the Raspberry Pi thanks to its lightweight nature. This is why the Raspberry Pi Foundation has chosen it to be the recommended software for newcomers, and the one used for the examples in this book.
				To keep the download size to a minimum, the Raspberry Pi image for Debian includes only a subset of the software you’d find on a regular desktop version. These include tools for browsing the web, programming in Python, and using the Pi with a GUI. Additional software can be quickly installed though the use of the distribution’s package manager apt.
				The Raspberry Pi build of Debian includes a desktop environment known as the Lightweight X11 Desktop Environment (LXDE). Designed to offer an attractive user interface using the X Window System software, LXDE provides a familiar point-and-click interface which will be immediately accessible to anyone who has used Windows, OS X or other GUI-based operating systems in the past.
				
				The GUI doesn’t load by default in most Raspberry Pi distributions. To quickly load it and leave the text-based console behind, log in, type startx and then press the Enter key.
				If you’re using the recommended Debian distribution, you’ll find that you have plenty of preinstalled software to get started. While hardly an exhaustive example of the software available for the Pi, which numbers in the thousands of packages, it’s a good introduction to precisely what the system can do.
				The software provided with the Debian distribution is split into themed categories. To view these categories, you can left-click the menu icon, located on the bottom-left of the screen in LXDE (see Figure 2-1).
				
					Figure 2-1: The LXDE desktop, as loaded on the Debian Raspberry Pi distribution
				
				
				The following lists describe the software packages, grouped by category.
				Accessories
				Debian Reference—A built-in reference guide, this provides a detailed explanation of the Debian Linux distribution and how programmers can contribute to its development.
				File Manager—The PCManFM file manager provides a graphical browser for files stored on the Pi or any connected storage device.
				Image Viewer—The GPicView lets you view images, such as those from a digital camera or on a connected storage device.
				Leafpad—This is a simple text editor, which is useful for making quick notes or writing simple programs.
				LXTerminal—This LXDE terminal package allows you to use the Linux command line in a window without leaving the graphical user interface.
				Root Terminal—Similar to LXTerminal, the Root Terminal automatically logs you in as the root super-user account in order to carry out system maintenance tasks unavailable to a regular user account.
				Xarchiver—If you need to create or extract compressed files, such as ZIP archives, this is the tool for the job.
				Education
				Scratch—A graphical programming language aimed at young children. You can learn more about Scratch in the Raspberry Pi User Guide (Wiley, 2012), or on the Scratch website at http://scratch.mit.edu.
				Squeak—The platform on which Scratch runs. You will rarely need to use this menu entry, and should instead use the Scratch entry above.
				Internet
				Midori—A fast yet lightweight web browser, Midori is equivalent to Internet Explorer in Windows or to Safari on OS X.
				Midori Private Browsing—Clicking on this menu entry loads the Midori web browser in private mode, meaning that sites you visit aren’t saved into the browser’s history.
				NetSurf Web Browser—An alternative to Midori, NetSurf can perform better on certain types of web page. Trying both will allow you to experiment and find the one which works best for you.
				Programming
				IDLE—An integrated development environment (IDE) written specifically for Python. You can learn more about IDLE and Python in the Raspberry Pi User Guide (Wiley, 2012), or on the official website at http://wiki.python.org/moin/BeginnersGuide.
				IDLE 3—Clicking this entry loads IDLE configured to use the newer Python 3 programming language, rather than the default Python 2.7 language. Both are largely compatible with each other, but some programs may require features of Python 3.
				Scratch—This shortcut opens the Scratch educational language, and is the same as the Scratch entry found in the Education category. Either can be used to start the program.
				Squeak—As with Scratch, this is a duplicate of the shortcut found in the Education category. You will rarely want to click this directly, and should instead use the Scratch shortcut. 
				Sound  Video
				Music Player—LXMusic is a simple and lightweight interface to the XMMS2 music playback software, allowing you to listen to music files while you work on the Pi.
				System Tools
				Task Manager—A tool for checking the amount of free memory available on the Pi, the current workload of the processor, and for closing programs which have crashed or are otherwise unresponsive.
				Preferences
				Customise Look and Feel—A toolkit for adjusting the appearance of the GUI, including the style and colour of windows.
				Desktop Session Settings—A tool for changing how the system works when the user is logged in, including what programs are automatically loaded and which window manager — the software which draws the borders and title bars of windows — is used.
				Keyboard and Mouse—A tool for adjusting input devices. If your keyboard is typing the wrong characters for certain keys, or your mouse is too sensitive, the settings can be altered here.
				Monitor Settings—The resolution that the monitor or TV connected to the Pi runs at can be altered here, although advanced changes require modification of configuration files. You’ll learn about this in Chapter 5, “Configuring the Raspberry Pi".
				Openbox Configuration Manager—The LXDE GUI uses a desktop environment called Openbox, which can be adjusted here. Using thist tool, you can apply new themes to change the GUI’s appearance, or alter how certain aspects of the interface operate.
				Preferred Applications—A tool for changing which applications are opened for particular file types. If you choose to use an alternative web browser, the system default can be changed here.
				
				Finding Help
				Linux is designed to be as user-friendly as possible to new users, even at the terminal command prompt. Although you’ll learn the most common ways to use each command in this chapter, not every option will be covered—to do so would require a much larger book.
				If you find yourself stuck, or if you want to learn more about any of the tools that are discussed in the following pages, there’s a command you should learn: man.
				Each Linux application comes with a help file, known as a man page—short for “manual page". It provides background on the software as well as details on what each of its options—known as flags—do and how to use them.
				To access the man page for a given tool, just type man followed by the command name. To see the man page for ls, a tool for listing the contents of directories, just type man ls.
				
				Using External Storage Devices
				The Pi’s SD card, which stores all the various Pi files and directories, isn’t very big. The largest available SD card at the time of writing is 64 GB, which is tiny compared to the 3,000 GB (3 TB) available from the largest full-size desktop hard drives.
				If you’re using your Pi to play back video files, you’ll likely need more storage than you can get from an SD card. As you learned in Chapter 1, “Meet the Raspberry Pi", it’s possible to connect USB Mass Storage (UMS) devices to the Pi in order to gain access to more storage space.
				Before these external devices are accessible, however, the operating system needs to know about them. In Linux, this process is known as mounting. If you’re running a version of Linux with a desktop environment loaded—like the recommended Debian distribution’s LXDE, loaded from the console with the startx command—this process is automatic. Simply connect the device to a free USB port on the Pi or a USB hub, and the device and its contents will be immediately accessible (see Figure 2-2).
				
					Figure 2-2: LXDE automatically mounting a USB mass storage device
				
				
				From the console, things are only slightly more difficult. To make a device accessible to Linux when the desktop environment isn’t loaded, follow these steps:
					1.	Connect the USB storage device to the Pi, either directly or through a connected USB hub.
					2.	Type sudo fdisk -l to get a list of drives connected to the Pi, and find the USB storage device by size. Note the device name: /dev/sdXN, where X is the drive letter and N is the partition number. If it is the only device connected to the Pi, this will be /dev/sda1.
					3.	Before the USB storage device is accessible, Linux needs a mount point for it. Create this by typing sudo mkdir /media/externaldrive.
					4.	Currently, the device is only accessible to the root user. To make it accessible to all users, type the following:
				sudo chgrp -R users /media/externaldrive  sudo chmod -R g+w /storage
					5.	Mount the USB storage device with mount sudo /dev/sdXN /media/harddrive -o=rw to gain access to the device and its contents.
				Creating a New User Account
				Unlike Windows and OS X, which are largely designed for use by a single individual, Linux is at heart a social operating system designed to accommodate numerous users. By default, Debian is configured with two user accounts: pi, which is the normal user account, and root, which is a superuser account with additional permissions.
				
				Don’t be tempted to log in as root all the time. Using a nonprivileged user account, you’re protected against accidentally wrecking your operating system and from the ravages of viruses and other malware downloaded from the Internet.
				While it’s certainly possible for you to use the pi account, it’s better if you create your own dedicated user account. Further accounts can also be created, for any friends or family members who might want to use the Pi.
				Creating a new account on the Pi is straightforward, and the same on all distributions, except for the username and password used to log on to the Pi initially. Just follow these steps:
					1.	Log in to the Pi using the existing user account (user name pi and password raspberry if you’re using the recommended Debian distribution).
					2.	Type the following:
				sudo useradd -m -G adm,dialout,cdrom,audio,plugdev,users,lpadmin,sambashare,vchiq,powerdev username
				This creates a new, blank user account. Note that the command should be typed as a single line, with no spaces after the commas.
					3.	To set a password on the new account, type sudo passwd username followed by the new password when prompted.
				To explain what just happened: the command sudo tells the operating system that the command you’re typing should be run as if you were logged in as the root account. The useradd command says you want to create a new user account. The -m section—known as a flag or an option—tells the useradd program to create a home directory where the new user can store his or her files. The big list following the -G flag is the list of groups of which the user should be a member.
				
				Users and Groups
				In Linux, each user has three main attributes: their User ID (UID), their Group ID (GID) and a list of supplementary group memberships. A user can be a member of as many groups as he or she pleases, although only one of these can be the user’s primary group. This is usually a self-named group matching the user name.
				Group membership is important. While users can be granted direct access to files and devices on the system, it’s more common for a user to receive access to these via group membership. The group audio, for example, grants all members the ability to access the Pi’s sound playback hardware. Without that membership, the user won’t be listening to any music.
				To see a user’s group memberships, type groups username at the terminal. If you use this on the default user pi, you’ll see the list of groups any new member should join to make use of the Pi. This is where the information used in step 2 of the preceding procedure was found.
				
				Installing and Uninstalling Software
				The default software installed with the Debian distribution is enough to get you started, but chances are you’re going to want to customise your Pi according to your own requirements.
				Installing new software onto the Pi is simple. The Debian distribution includes a tool called apt, which is a powerful package manager. Packages are what Linux calls a piece of software, or a collection of different pieces of software designed to work together.
				Although apt is designed to be operated from the command line, it’s very user-friendly and easy to learn. There are GUIs for apt, such as the popular Synaptic Package Manager, but they often struggle to run on the Pi due to the lack of memory. As a result, we recommend that software be installed at the terminal.
				
				Other Distributions
				Debian, and distributions based on Debian, typically use apt as the package manager. It’s not the only tool out there, and other distributions make different choices. Fedora Remix, for example, uses the pacman tool.
				Pacman is no more difficult to use than apt, but its syntax (the way it expects you to phrase instructions to install new software or remove existing software) is different. For instructions on how to use pacman instead of apt, type man pacman at the Fedora Remix terminal.
				Other distributions may use the yum package manager. If you’re trying a distribution that uses yum, simply type man yum at the terminal for instructions.
				
				A package manager’s job is to keep track of all the software installed on the system. It doesn’t just install new software—it also keeps tabs on what is currently installed, allows old software to be removed and installs updates as they become available.
				Package management is one of the areas where Linux differs greatly from operating systems like Windows or OS X. Although it’s possible to manually download new software to install, it’s far more common to use the built-in package management tools instead.
				
				Before trying to install new software or upgrade existing software, you need to make sure the apt cache is up to date. To do this, simply type the command sudo apt-get update.
				Finding Software
				The first step to installing a new piece of software is to find out what it’s called. The easiest way to do this is to search the cache of available software packages. This cache is a list of all the software available to install via apt, stored on Internet servers known as repositories.
				The apt software includes a utility for managing this cache, called apt-cache. Using this software, it’s possible to run a search on all the available software packages for a particular word or phrase.
				For example, to find a game to play, you can type the following command:
				apt-cache search game
				That tells apt-cache to search its list of available software for anything which has the word “game" in its title or description. For common search terms, you can end up with quite a list (see Figure 2-3), so try to be as specific as you can.
				
					Figure 2-3: The last few results for an apt-cache “game" search
				
				
				
				If your search term brings up too many different packages to see on a single screen display, you can tell Linux that you want it to pause on each screenfull by piping the output of apt-cache through a tool called less. Simply change the command to apt-cache search game | less and use the cursor keys to scroll through the list. Press the letter Q on the keyboard to exit.
				Installing Software
				Once you know the name of the package you want to install, switch to the apt-get command in order to install it. Installing software is a privilege afforded only to the root user, as it affects all users of the Pi. As a result, the commands will need to be prefaced with sudo to tell the operating system that it should be run as the root user.
				For example, to install the package thrust (a Linux version of a popular Commodore 64 game from days gone by), you would simply use the install command with apt-get as follows: 
				sudo apt-get install thrust
				Some packages rely on other packages in order to operate. A programming language may depend on a compiler, a game engine on graphics files, or an audio player on codecs for playing back different formats. These are known in Linux terms as dependencies.
				Dependencies are one of the biggest reasons for using a package manager like apt rather than installing software manually. If a package depends on other packages, apt will automatically find them (see Figure 2-4) and prepare them for installation. If this happens, you’ll be shown a prompt asking whether you want to continue. If you do, type the letter Y and press the Enter key.
				
					Figure 2-4: Apt listing the dependencies for the OpenOffice.org package
				
				
				Uninstalling Software
				If you decide you no longer want a piece of software, apt-get also includes a remove command that cleanly uninstalls the package along with any dependencies which are no longer required. When you’re using a smaller SD card with the Pi, the ability to try out software and quickly remove it is extremely useful.
				To remove thrust, simply open the terminal and type the following command:
				sudo apt-get remove thrust
				The remove command has a more powerful brother in the form of the purge command. Like remove, the purge command gets rid of software you no longer require. Where remove leaves the software’s configuration files intact, however, purge removes everything. If you’ve got yourself into a mess customising a particular package and it no longer works, purge is the command to use. For example, to purge thrust, you would just type this:
				sudo apt-get purge thrust
				Upgrading Software
				In addition to installing and uninstalling packages, apt can be used to keep them up to date. Upgrading a package through apt ensures that you’ve received the latest updates, bug fixes and security patches.
				Before trying to upgrade a package, make sure the apt cache is as fresh as possible by running an update:
				sudo apt-get update
				When upgrading software, you have two choices: you can upgrade everything on the system at once or upgrade individual programs. If you just want to keep your distribution updated, the former is achieved by typing the following:
				sudo apt-get upgrade
				To upgrade an individual package, simply tell apt to install it again. For example, to install a thrust upgrade, you would type this: 
				sudo apt-get install thrust
				If the package is already installed, apt will treat it as an in-place upgrade. If you’re already running the latest version available, apt will simply tell you it cannot upgrade the software and exit.
				
				For more information on package management with apt—in particular, how certain packages can be “kept back" and excluded from upgrades—type man apt at the terminal.
				
				
			
		
	




	
		9781118494684-ch03.g.html
		
	
	
		
			
				Chapter 3
				Troubleshooting
				Sometimes, things don’t go entirely smoothly. The more complex the device, the more complex the problems that can occur—and the Pi is an extremely complex device indeed.
				Thankfully, many of the most common problems are straightforward to diagnose and fix. In this chapter, we’ll look at some of the most common reasons for the Pi to misbehave and how to fix them.
				Keyboard and Mouse Diagnostics
				Perhaps the most common problem that users experience with the Raspberry Pi is when the keyboard repeats certain characters. For example, if the command startx appears onscreen as sttttttttttartxxxxxxxxxxxx, it will, understandably, fail to work when the Enter key is pressed.
				There are typically two reasons why a USB keyboard fails to operate correctly when connected to the Raspberry Pi: it’s drawing too much power, or its internal chipset is conflicting with the USB circuitry on the Pi.
				Check the documentation for your keyboard, or the label on its underside, to see if it has a power rating given in milliamps (mA). This is how much power the keyboard attempts to draw from the USB port when it’s in use. 
				The Pi’s USB ports have a component called a polyfuse connected to them, which protects the Pi in the event that a device attempts to draw too much power. When this polyfuse is tripped, it causes the USB port to shut off, at around 150 mA. If your keyboard draws anywhere around that much power, it may operate strangely—or not at all. This can be a problem for keyboards that have built-in LED lighting, which require far more power to operate than a standard keyboard.
				If you find that your USB keyboard may be drawing too much power, try connecting it to a powered USB hub instead of directly to the Pi. This will allow the keyboard to draw its power from the hub’s power supply unit, instead of from the Pi itself. Alternatively, swap the keyboard out for a model with lower power demands. The repeating-letter problem may also be traced to an inadequate power supply for the Pi itself, which is addressed in the next section, “Power Diagnostics".
				The issue of compatibility, sadly, is harder to diagnose. While the overwhelming majority of keyboards work just fine with the Pi, a small number exhibit strange symptoms. These range from intermittent response, the repeating-letter syndrome or even crashes that prevent the Pi from operating. Sometimes, these issues don’t appear until other USB devices are connected to the Pi. If your keyboard was working fine until another USB device, in particular a USB wireless adapter, was connected, you may have an issue of incompatibility.
				If possible, try swapping the keyboard out for another model. If the new keyboard works, your old one may be incompatible with the Pi. For a list of known-incompatible keyboards, visit the eLinux wiki: http://elinux.org/RPi_VerifiedPeripherals#Problem_USB_Keyboards
				The same advice on checking compatibility in advance applies to problems with the mouse: the majority of USB mice and trackballs work fine, but some exhibit incompatibility with the Pi’s own USB circuitry. This usually results in symptoms like a jerky or unresponsive mouse pointer, but it can sometimes lead to the Pi failing to load or crashing at random intervals. If you’re looking to buy a new mouse, an up-to-date list of models known to work with the Pi is available at the eLinux wiki site: http://elinux.org/RPi_VerifiedPeripherals#Working_USB_Mouse_Devices
				Power Diagnostics
				Many problems with the Raspberry Pi can be traced to an inadequate power supply. The Model A requires a 5 V supply capable of providing a 500 mA current, while the Model B’s extra components bump up the current requirement to 700 mA. Not all USB power adapters are designed to offer this much power, even if their labelling claims otherwise.
				
				The formal USB standard states that devices should draw no more than 500 mA, with even that level of power only available to the device following a process called negotiation. Because the Pi doesn’t negotiate for power, it’s unlikely that it will work if you connect it to the USB ports on a desktop or laptop computer.
				If you’re having intermittent problems with your Pi—particularly if it works until you connect something to a USB port or start a processor-intensive operation like playing video—the chances are that the power supply in use is inadequate. The Pi provides a relatively easy way to check if this is the case in the form of two voltage test points.
				To use the voltage test points, you’ll need a voltmeter or multimeter with direct current (DC) voltage measuring capabilities. If your meter has multiple inputs for different voltages, use the lowest setting.
				
				Avoid touching the test probes to anything not labelled as a test point. It’s possible to bridge the 5 V supply that comes in to the Pi to the internal 3.3 V supply, creating a short circuit which can damage the device. Be especially careful around exposed header pins.
				The two test points are small, copper-clad holes known as vias, which are connected to the Pi’s 5 V and ground circuits. Put the positive (red) meter probe on TP1, located to the left of the board just above a small black component called a regulator labelled RG2. Connect the black (negative) meter probe to TP2, located between the copper GPIO pins and the yellow-and-silver RCA phono connector at the top-left of the board (see Figure 3-1).
				
					Figure 3-1: The two voltage test points, labelled TP1 and TP2
				
				
				The reading on the voltmeter should be somewhere between 4.8 V and 5 V. If it’s lower than 4.8 V, this indicates that the Pi is not being provided with enough power. Try swapping the USB adapter for a different model, and check that the label says it can supply 700 mA or more. A model rated at 1A is recommended, but beware of cheap models—they sometimes have inaccurate labelling, and fail to supply the promised current. Genuine branded mobile phone chargers rarely have this problem, but cheap unbranded devices—often sold as compatible adapters—should be avoided
				If your voltmeter reads a negative number, don’t worry: this just means you’ve got the positive and negative probes in the wrong place. Either swap them around or just ignore the negative sign when noting your reading.
				Display Diagnostics
				Although the Pi is designed to work with almost any HDMI, DVI or composite video display device, it simply may not work as expected when you plug it in. For example, you may find that your picture is shifted to the side or not fully displayed, or is only visible as a postage stamp-sized cut-out in the middle of the screen or in black-and-white—or even missing entirely.
				First, check the type of device to which the Pi is connected. This is especially important when you’re using the composite RCA connection to plug the Pi into a TV. Different countries use different standards for TV video, meaning that a Pi configured for one country may not work in another. This is the usual explanation for a Pi showing black-and-white video. You’ll learn how to adjust this setting in Chapter 5, “Configuring the Raspberry Pi".
				When you use the HDMI output, the display type is usually automatically detected. If you’re using an HDMI to DVI adapter to plug the Pi into a computer monitor, however, this occasionally goes awry. Common symptoms include snow-like static, missing picture portions or no display at all. To fix this, note the resolution and refresh rate of your connected display, and then jump to Chapter 5 to find out how to set these manually.
				Another issue is a too-large or too-small image, either missing portions at the edge of the screen or sitting in the middle of a large black border. This is caused by a setting known as overscan, which is used when the Pi is connected to TVs to avoid printing to portions of the display which may be hidden under a bezel. As with other display-related settings, you will learn how to adjust—or even completely disable—overscan in Chapter 5.
				Boot Diagnostics
				The most common cause for a Pi to fail to boot is a problem with the SD card. Unlike a desktop or laptop computer, the Pi relies on files stored on the SD card for everything. If Pi can’t talk to the card, it won’t display anything on the screen or show any signs of life at all.
				If your Pi’s power light glows when you connect the micro-USB power supply, but nothing else happens and the OK light remains dark, you have an SD card problem. First, ensure that the card works when you connect it to a PC, and that it shows the partitions and files expected of a well-flashed card. (For more details, see Chapter 2, “Linux System Administration", particularly the section titled “File System Layout" in that chapter.)
				If the card works on a PC but not in the Pi, it may be a compatibility problem. Some SD cards—especially high-speed cards marked as Class 10 on their labelling—don’t operate correctly when connected to the Pi’s onboard SD card reader. A list of cards known to cause compatibility problems with the Pi can be found on the eLinux wiki: http://elinux.org/RPi_VerifiedPeripherals#Problem_SD_Cards
				Sadly, if you have one of the cards on the list, you may need to replace it with a different card in order for the Pi to work. As the Pi’s software base is developed, however, work is being carried out to ensure that a wider range of cards operate correctly with the Pi. Before giving up on a high-speed card completely, check to see if an updated version of your chosen Linux distribution is available. (See Chapter 1, “Meet the Raspberry Pi", for more information about distributions.)
				Network Diagnostics
				The most useful tool for diagnosing network problems is ifconfig. If you’re using a wireless network connection, jump to Chapter 4, “Network Configuration", for information on a similar tool for those devices. Otherwise, read on.
				Designed to provide information on connected network ports, ifconfig is a powerful tool for controlling and configuring the Pi’s network ports. For its most basic usage, simply type the tool’s name in the terminal:
				ifconfig
				Called in this manner, ifconfig provides information on all the network ports it can find (see Figure 3-2). For the standard Raspberry Pi Model B, there are two ports: the physical Ethernet port on the right-hand side of the board, and a virtual loopback interface that allows programs on the Pi to talk to each other.
				
					Figure 3-2: The output of ifconfig on a Raspberry Pi Model B
				
				
				The output of ifconfig is split into the following sections:
				Link encap—The type of encapsulation used by the network, which on the Model B will either read Ethernet for the physical network port or Local Loopback for the virtual loopback adaptor.
				Hwaddr—The Media Access Control (MAC) address of the network interface, written in hexadecimal. This is unique for every device on the network, and each Pi has its own MAC address, which is set at the factory.
				inet addr—The internet protocol (IP) address of the network interface. This is how you find the Pi on the network if you’re using it to run a network-accessible service, such as a web server or file server.
				Bcast—The broadcast address for the network to which the Pi is connected. Any traffic sent to this address will be received by every device on the network.
				Mask—The network mask, which controls the maximum size of the network to which the Pi is connected. For most home users, this will read 255.255.255.0.
				MTU—The maximum transmission unit size, which is how big a single packet of data can be before the system needs to split it into multiple packets.
				RX—This section provides feedback on the received network traffic, including the number of errors and dropped packets recorded. If you start to see errors appearing in this section, there’s something wrong with the network.
				TX—This provides the same information as the RX section, but for transmitted packets. Again, any errors recorded here indicate a problem with the network.
				collisions—If two systems on the network try to talk at the same time, you get a collision which requires them to retransmit their packets. Small numbers of collisions aren’t a problem, but a large number here indicates a network issue.
				txqueuelen—The length of the transmission queue, which will usually be set to 1000 and rarely needs changing.
				RX bytes, TX bytes—A summary of the amount of traffic the network interface has passed.
				If you’re having problems with the network on the Pi, you should first try to disable and then re-enable the network interface. The easiest way to do this is with two tools called ifup and ifdown.
				If the network is up, but not working correctly—for example, if ifconfig doesn’t list anything in the inet addr section—start by disabling the network port. From the terminal, type the following command:
				sudo ifdown eth0
				Once the network is disabled, make sure that the cable is inserted tightly at both ends, and that whatever network device the Pi is connected to (hub, switch or router) is powered on and working. Then bring the interface back up again with the following command:
				sudo ifup eth0
				You can test the networking by using the ping command, which sends data to a remote computer and waits for a response. If everything’s working, you should see the same response as shown in Figure 3-3. If not, you may need to manually configure your network settings, which you’ll learn how to do in Chapter 4, “Network Configuration".
				
					Figure 3-3: The result of a successful test of the network, using the ping command
				
				
				The Emergency Kernel
				The Linux kernel is the heart of the operating system that drives the Pi. It’s responsible for everything from making sure that you can access your files to allowing programs to talk to other programs.
				When switched on, your Pi will load the normal, default kernel. There’s also a second kernel included in most distributions, which sits unused. This is the emergency kernel, and as the name suggests, it is typically used only when the normal kernel isn’t working.
				It’s highly unlikely that you’ll ever need to boot a Pi using the emergency kernel, but it’s worth learning how to do so just in case. This is especially important if you’re upgrading your kernel or are using a new and potentially poorly tested distribution. Sometimes, newly-released software can have bugs which aren’t spotted before its release. When encountering strange errors after upgrading, the emergency kernel can be used to narrow down the problem to the new kernel version.
				The Linux kernel is a single file located in the /boot directory called kernel.img. When the Pi is first switched on and begins to load the operating system, it looks for this file, and if the file is missing, the Pi won’t work. The emergency kernel is a second file, again in the /boot directory, called kernel_emergency.img.
				The emergency kernel is, in most cases, almost identical to the standard kernel. When changes are made to the standard kernel, to boost performance or add new features for example, the emergency kernel is left unaltered. This way, if the changes to the standard kernel cause stability problems, a user can simply tell the Pi to load the emergency kernel instead.
				There are two ways to boot into the emergency kernel, and both require the use of a PC and an SD card reader if the Pi can’t boot. Otherwise, the following can be carried out on the Pi itself.
				The easiest way to boot the emergency kernel is to rename the existing kernel.img file to kernel.img.bak, and then rename the kernel_emergency.img file to kernel.img. When the Pi loads, it will now load the emergency kernel by default. To go back to the standard kernel, simply reverse the process: rename kernel.img to kernel_emergency.img and kernel.img.bak to kernel.img.
				An alternative method to load the emergency kernel is to edit the cmdline.xt file (located in the /boot directory) by adding the following entry at the end of the existing command line:
				kernel=kernel_emergency.img
				This tells the Pi that it should load the kernel named kernel_emergency.img instead of the usual kernel.img. Reversing the process is as simple as opening cmdline.txt again and removing the entry.
				You’ll learn more about cmdline.txt and how it affects the operation of the Raspberry Pi in Chapter 5, “Configuring the Raspberry Pi".
				
				
			
		
	




	
		9781118494684-ch04.g.html
		
	
	
		
			
				Chapter 4
				Network Configuration
				For most users, configuring the Pi’s network is as easy as plugging a cable into the Model B’s Ethernet port—or a USB Ethernet adapter in the case of the Model A. For others, however, the network requires manual configuration.
				If you know that your network doesn’t have a Dynamic Host Configuration Protocol (DHCP) server—a system that tells the Pi and other devices on the network how they should connect—or if you want to use a USB wireless adapter with the Pi, read on.
				Wired Networking
				If the network still doesn’t work, you may need to configure it manually. Normally, the network in a home, school or office has a DHCP server that tells the Pi and other devices on the network how they should connect. Some networks, however, don’t have a DHCP server and need to be set up manually.
				The list of network interfaces, along with information about how they should be configured, is stored in a file called interfaces located in the folder /etc/network. This is a file only the root user can edit, because removing a network interface from this list will cause it to stop working.
				From the terminal, you can edit this file using a variety of different text editors. For simplicity, the nano text editor should be used for this process. Open the file for editing with the following command:
				sudo nano /etc/network/interfaces
				Nano is a powerful yet lightweight text editor, with a simple user interface (see Figure 4-1). You can move your cursor around the document with the arrow keys, save by holding down the CTRL key and pressing O, and quit by holding down the CTRL key and pressing X.
				
					Figure 4-1: Editing /etc/network/interfaces with nano
				
				
				The line you need to edit for manual configuration starts with iface eth0 inet. Delete dhcp from the end of this line and replace it with static, press Enter to start a new line, and then fill in the remaining details in the following format with a tab at the start of each line:
				[Tab] address xxx.xxx.xxx.xxx
				[Tab] netmask xxx.xxx.xxx.xxx
				[Tab] gateway xxx.xxx.xxx.xxx
				Make sure that you press the Tab key at the start of each line, and don’t actually type [Tab]. The x characters in the configuration lines represent network addresses you’ll need to enter. For address, you should enter the static IP address that you want to assign to the Pi. For netmask, you should enter the network mask—which controls the size of the connected network—in what is known as dotted-quad format. If you’re using a home network, this is typically 255.255.255.0. For gateway, you should enter the IP address of your router or cable modem.
				As an example, the settings for a common home network would look like this:
				iface eth0 inet static
				[Tab] address 192.168.0.10
				[Tab] netmask 255.255.255.0
				[Tab] gateway 192.168.0.254
				When you’ve finished editing the file, press CTRL + O to save it, and then press CTRL + X to leave nano and return to the terminal. To use your new network settings, restart the networking service by typing the following:
				sudo /etc/init.d/networking restart
				If you need to return to automatic settings via DHCP, you need to edit the interfaces file again and delete the address, netmask and gateway settings. Replace static with dhcp at the end of the iface line, and then restart the networking service again.
				Setting a manual IP address isn’t quite enough to get your Pi connected to the outside world. Computers on modern networks have both a numerical address identifier known as an IP address and a hostname or domain name. It’s this latter, friendly name which means you can simply type www.raspberrypi.org into your browser, instead of trying to remember 93.93.128.176.
				A system called a Domain Name Service (DNS) server is responsible for looking up the friendly names you supply and converting them into the numbers required to access the system. It operates much like an automated telephone directory. Before you’ll be able to access Internet-connected systems via their domain names, you’ll need to tell the Pi which DNS servers to use.
				The list of DNS servers, known as nameservers in Linux parlance, is stored in /etc/resolv.conf. When the system gets its details through DHCP, this file is automatically filled in. When you set an address manually, you need to provide the addresses of the nameservers on your network. Normally, this would be the address of your router as found in the gateway line from the interfaces file (described earlier in this chapter).
				To set the nameservers, open the file with nano by typing the following command at the terminal:
				sudo nano /etc/resolv.conf
				Add each nameserver on a separate line, prefaced with nameserver and a space. As an example, the resolv.conf configuration for a network which uses Google’s publicly-accessible nameservers to resolve domain names would appear like this:
				nameserver 8.8.8.8
				nameserver 8.8.4.4
				You’ll notice that the nameserver addresses need to be supplied as IP addresses, rather than domain names. If you provided domain names instead, the Pi would enter an infinite loop of trying to find a nameserver to ask how it can find the nameservers.
				Save the file by pressing CTRL + O, and then quit nano by pressing CTRL + X. Restart the networking interface by typing the following:
				sudo /etc/init.d/networking restart
				Then test the settings by either opening a web browser or using the following ping command (see Figure 4-2):
				ping -c 1 www.raspberrypi.org
				
					Figure 4-2: A successful test of networking on the Raspberry Pi Model B
				
				
				Wireless Networking
				Although no current models of the Raspberry Pi include Wi-Fi networking hardware onboard, it’s possible to add wireless connectivity with a simple USB Wi-Fi adapter. However, you will need to configure the adapter before you can use it to get your Pi online.
				
				USB Wi-Fi adapters are very power-hungry. If you connect one directly to the Pi’s USB port, the chances are it simply won’t work. Instead, connect a powered USB hub to the Pi, and then insert the Wi-Fi adapter into that.
				Before you start to set up the wireless interface, you’ll need to know the Service Set Identifier (SSID)—also known as the network name—of the wireless router to which you want to connect, along with the type of encryption in use and the password required. You’ll also need to know what type of wireless network it is. A USB adapter designed for 802.11a Wi-Fi may not connect to an 802.11g network, and vice versa.
				In order for the USB wireless adapter to be addressed by the system, a software bundle known as a firmware is required. While some distributions include a selection of the most common Wi-Fi firmware installed by default, others do not. At present, to save space, most distributions designed for the Raspberry Pi need the firmware files for a wireless card installing manually.
				This, unfortunately, can lead to a Catch-22 situation: in order to download the firmware files, the Pi must be connected to the Internet. If you can spare a wired port on your router or gateway for a few minutes, that’s not a problem. However, if wireless is your only way of getting online, you’ll need to manually download the firmware installation package on a different computer, and then transfer it across to the Pi by either copying it to the Pi’s SD card or connecting an external storage device such as a USB flash drive.
				To find the correct firmware file to download, you’ll need to know what type of wireless adapter you have. Although various companies sell branded USB wireless adapters, the number of companies that actually manufacture the components is a lot smaller. Several different manufacturers may use the same type of chip inside their USB wireless adapters, making them all compatible with the same firmware. As a result, the labelling on a device or its packaging is not enough to know which firmware you should install. Instead, you’ll need to connect the device to the Pi and check the kernel ring buffer for error messages. If you’ve already connected the wireless adapter as instructed in Chapter 1, “Meet the Raspberry Pi", you can continue. If not, connect the adapter now.
				The kernel ring buffer is a special portion of memory used by the Linux kernel to store its human-readable output. It’s an important part of the Linux operating system: the text flashes by too quickly to read while the Pi boots, so it’s critical that users are able to view the messages at a later date to read errors and diagnose problems.
				With the adapter connected but no wireless firmware packages installed, the kernel will print a series of error messages to the ring buffer. To read these messages, you can use the dmesg command to print the contents of the buffer to the screen. At the terminal, or at the console if you haven’t loaded the desktop environment, simply type the following command to view the buffer:
				dmesg
				This will print out the entire kernel ring buffer, which will contain all messages output by the kernel since the Pi was switched on. If the Pi has been running a while, that can be a lot of text. To locate error message particular to the wireless adapter, it can help to send the output of dmesg through a tool called grep. Using grep, you can search through the buffer for text relating to missing firmware. By piping the output of dmesg through grep with a search term, things become significantly clearer. Type the following at the terminal:
				dmesg | grep ^usb
				The | symbol is known as a pipe, and tells Linux to send the output of one program—which would normally go to a file or the screen—to the input of another. Multiple programs can be chained this way. In this example, grep is being told to search through the output of dmesg—the screens full of text from the earlier command—for any use of the term usb at the start of the line (denoted by the ^ character).
				The exact output of that search will depend on the manufacturer of your USB wireless adapter. In Figure 4-3, the output is shown with a Zyxel NWD2015 Wireless USB Adapter connected to the Pi.
				
					Figure 4-3: Searching the kernel ring buffer for usb with a Zyxel wireless adapter connected
				
				
				The important part of this output is the line that reads Manufacturer. In the case of the example Zyxel NWD2105, this reads Ralink, which is the company that makes the actual chip found inside Zyxel USB wireless adapter. It’s this company’s firmware that must be installed for the wireless adapter to work.
				
				If you couldn’t find anything using usb as a search term, you can try the same command using the search term firmware, wlan or wireless. If you still can’t see anything useful, type lsusb for a list of all USB devices connected to the system.
				Using the manufacturer name from dmesg, search for the firmware files using the apt-cache search tool introduced earlier in this chapter. For the example Zyxel NWD2015 adapter, the apt-cache command would be
				apt-cache search ralink
				If apt-cache fails to find the firmware, you may need to make a guess based on the firmware packages in the following list. Don’t worry if you install the wrong one—any firmware can be quickly uninstalled using apt-get remove, and having multiple firmware packages does no harm. The following wireless firmware packages are available in the recommended Debian distribution on the Raspberry Pi:
				atmel-firmware—For devices based on the Atmel AT76C50X chipset
				firmware-atheros—For devices based on Atheros chipsets
				firmware-brcm80211—For devices based on Broadcom chipsets
				firmware-intelwimax—For devices based on Intel’s WiMAX chipsets
				firmware-ipw2x00—For Intel Pro Wireless adapters (including 2100, 2200 and 2915)
				firmware-iwlwifi—For other Intel wireless adapters (including 3945, 4965 and the 5000 series)
				firmware-ralink—For devices based on Ralink chipsets
				firmware-realtek—For devices based on Realtek chipsets
				zd1211-firmware—For devices based on the ZyDAS 1211 chipset
				The firmware for the example Zyxel wireless adapter is provided by the firmware-ralink package in this list. This package can be installed using apt-get, but only while the Pi is connected to the Internet through its wired Ethernet port or a USB Ethernet adapter. When connected, install the firmware by typing the following:
				sudo apt-get install firmwarepackage
				Replace firmwarepackage in this command with the name of the package that you found by using apt-cache. For the example Zyxel NWD2105, the full command would be sudo apt-get install firmware-ralink.
				
				Installing Wireless Firmware Offline
				If you can’t connect the Pi to the Internet using any method other than a wireless connection, you’ll need to download the firmware on a different computer. In a web browser, load a search engine and type the name of the firmware package followed by the name of the distribution you’re using and its version.
				If you’re using the recommend Debian distribution, the firmware for the Ralink RT2x00 chipset from the example can be found by searching for firmware-ralink debian wheezy. The search will lead you to a package file to download. In the case of Debian, this is a .deb file. For Fedora Remix, the same firmware is provided as a .rpm file.
				Download this file, and then copy it to the Pi’s SD card in the /home/pi directory, or onto a USB flash drive or other external storage device. Load the Pi, and then when it comes time to install the firmware, replace the package name with the name of the file you downloaded. For the example Zyxel NWD2105 card, the command would be the following:
				sudo apt-get install firmware-ralink_0.35_all.deb
				
				With the firmware installed, disconnect the USB wireless adapter and reconnect it to the Pi. This will restart the kernel’s search for the firmware files, which it will now be able to find. These files will remain in place, and load automatically when the USB wireless adapter is connected. You will only have to perform the installation process once.
				With the firmware installed, setting the wireless connection up should be straightforward. First, check that the USB wireless adapter is working as it should by using the iwlist command to scan for nearby wireless access points. This list will probably be larger than a single screen, so pipe the command’s output through less to pause after each screenful, like this:
				sudo iwlist scan | less
				This command will return a list of all the wireless networks reachable from the Pi and their details (see Figure 4-4). If you receive an error message at this point—in particular, one that claims the network or interface is down—check that you have installed the correct firmware, and that the USB wireless adapter is connected to a powered USB hub.
				
					Figure 4-4: Scanning for wireless networks with iwlist
				
				
				You can check the current status of the network using the iwconfig command. Like ifconfig, the iwconfig command allows you to check the status of a network interface and issue configuration commands. Unlike ifconfig, however, iwconfig is specifically designed for wireless networks and includes specific features for this. Type the command name at the terminal as follows:
				iwconfig
				The output of iwconfig, as shown in Figure 4-5, is split into the following sections:
				Interface Name—Each device has its own interface name, as with wired networks. If the interface is a wireless connection, additional details will be shown. The default name for a Pi’s wireless connection is wlan0.
				Standard—The IEEE 802.11 wireless standards have a variety of different types, distinguished by a letter suffix. This section lists the standards supported by the USB wireless adapter. For the example adapter, this reads IEEE 802.11bgn for the network types it can address.
				ESSID—The SSID of the network to which the adapter is connected. If the adapter is not currently connected to a network, this will read off/any.
				Mode—The mode that the adapter is currently operating in, which will be one of the following:
				•	Managed—A standard wireless network, with clients connecting to access points. This is the mode used for almost all home and business networks.
				•	Ad-Hoc—A device-to-device wireless network, with no access points.
				•	Monitor—A special mode in which the card listens out for all traffic whether or not it is the addressee. This mode is typically used in network troubleshooting for capturing wireless network traffic.
				•	Repeater—A special mode that forces a wireless card to forward traffic on to other network clients, to boost signal strength.
				•	Secondary—A subset of the Repeater mode, which forces the wireless card to act as a backup repeater.
				Access Point—The address of the access point to which the wireless adapter is currently connected. If the adapter isn’t connected to a wireless access point, this will read Not-Associated.
				Tx-Power—The transmission power of the wireless adapter. The number displayed here indicates the strength of the signal that the adapter is sending: the higher the number, the stronger the signal.
				Retry—The current setting for the wireless adapter’s transmission retry, used on congested networks. This does not normally need changing, and some cards won’t allow it to be changed.
				RTS—The adapter’s current setting for Ready To Send and Clear To Send (RTS/CTS) handshaking, used on busy networks to prevent collisions. This is normally set by the access point on connection.
				Fragment—The maximum fragment size, used on busy networks to split packets up into multiple fragments. This is normally set by the access point on connection.
				Power Management—The current status of the adapter’s power management functionality, which reduces the device’s power demands when the wireless network is idle. This has little effect on the Pi, but is typically enabled for battery-powered devices like a laptop.
				
					Figure 4-5: The output of iwconfig when not connected to a wireless network
				
				
				To connect the Pi to a wireless network, you will need to add some lines into the /etc/network/interfaces file. (For full details on how this file is laid out, see the “Wired Networking" section earlier in this chapter.) First, open the file in the nano text editor:
				sudo nano /etc/network/interfaces
				At the bottom of the file, create a new entry for the USB wireless adapter that reads as follows (see Figure 4-6):
				auto wlan0
				iface wlan0 inet dhcp
				wpa-conf /etc/wpa.conf
				
					Figure 4-6: Editing the interfaces file for wireless network access
				
				
				Once the entry is in place, save the file by pressing CTRL + O and then quit nano with CTRL + X.
				
				The device ID of wlan0 is correct if this is the first wireless device you’ve set up on your Pi. If it isn’t, the number at the end will be different. Type iwconfig to see a current list of wireless devices, and change the lines in the preceding code example accordingly.
				The last line of the interfaces file makes reference to a configuration file, wpa.conf, which does not yet exist. This file is used by a tool known as wpasupplicant, designed to provide Linux with an easy way to connect to networks secured with Wireless Protected Access (WPA) encryption.
				Using wpasupplicant, you can connect the Pi to almost any wireless network—regardless of whether it's protected by WPA or its newer replacement WPA2—in both Advanced Encryption Standard (AES) and Temporal Key Integrity Protocol (TKIP) modes. Despite its name, wpasupplicant also allows connection to wireless networks using the older Wired Equivalent Privacy (WEP) encryption standard.
				The wpasupplicant program stores its configuration in a file called wpa.conf, located in the /etc directory. To begin configuring the Pi for wireless access, first open a new blank file for editing by typing the following:
				sudo nano /etc/wpa.conf
				Enter the following two lines, which again, are the same for any wireless network type. Replace Your_SSID with the SSID for the wireless network to which you want to connect, and then finish the file with the lines that match your network’s encryption type.
				network={
				[Tab] ssid="Your_SSID"
				At this point in the configuration file, the details required differ depending on the type of wireless network you are configuring. The following subsections provide instructions for completing the configuration for unencrypted, WEP and WPA networks.
				No Encryption
				If your wireless network has no encryption in place, finish the wpa.conf file as follows:
				[Tab] key-mgmt=NONE
				}
				Save the file with CTRL + O, and then exit nano with CTRL + X.
				WEP Encryption
				If your wireless network uses WEP encryption, finish the wpa.conf file as follows:
				[Tab] key-mgmt=NONE
				[Tab] wep_key0="Your_WEP_Key"
				}
				Replace Your_WEP_Key with the ASCII key for your wireless network’s WEP encryption. Save the file with CTRL + O, and then exit nano with CTRL + X.
				
				WEP encryption is extremely insecure. Readily-available software can break the encryption on a WEP-protected network in just a few minutes, allowing a third party to use your network. If you’re still running WEP, consider switching to WPA or WPA2 for better security.
				WPA/WPA2 Encryption
				If your wireless network uses WPA or WPA2 encryption, finish the wpa.conf file as follows:
				[Tab] key_mgmt=WPA-PSK
				[Tab] psk="Your_WPA_Key"
				}
				Replace Your_WPA_Key with the pass phrase for your wireless network’s encryption. Figure 4-7 shows an example configuration for a wireless network with the SSID “Private_Router" and the WPA pass phrase “Private Wireless Network". Save the file with CTRL + O, and then exit nano with CTRL + X.
				
					Figure 4-7: Editing the wpa.conf file for a WPA-protected network
				
				
				Connecting to the Wireless Network
				The Pi’s wireless networking is now configured, and will begin the next time the Pi is restarted. To start the wireless network without rebooting, type the following:
				sudo ifup wlan0
				To make sure that the network is operational, unplug the Pi’s Ethernet cable (if attached) and type the following:
				ping -c 1 www.raspberrypi.org
				
				If you start having problems with your Pi following the installation of a USB wireless adapter, it could be due to a conflict with other USB devices. Some adapter models are known to cause problems with certain USB keyboards. For an up-to-date list of adapters that are known to be good, as well as those that are known to cause conflicts, visit http://www.element14.com/community/docs/DOC-44703/l/raspberry-pi-wifi-adapter-testing or the eLinux wiki at http://elinux.org/RPi_VerifiedPeripherals#Working_USB_Wifi_Adapters.
				
				
			
		
	




	
		9781118494684-ch05.g.html
		
	
	
		
			
				Chapter 5
				Configuring the Raspberry Pi
				Because of its origins in embedded computing, the BCM2835 chip at the heart of the Raspberry Pi doesn’t have anything like a PC’s BIOS menu where various low-level system settings can be configured. Instead, it relies on text files containing configuration strings that are loaded by the chip when the power is switched on.
				Before taking a look at the various options available in these files—config.txt, cmdline.txt and start.elf—a word of warning: changing some of these settings away from their defaults can result in a Pi that, best case, doesn’t boot until the files are reverted and, worst case, can physically damage the system. These potentially dangerous settings will be highlighted with warnings in this chapter.
				Hardware Settings—config.txt
				The Pi’s hardware is controlled by settings contained in a file called config.txt, which is located in the /boot directory (see Figure 5-1). This file tells the Pi how to set up its various inputs and outputs, and at what speed the BCM2835 chip and its connected memory module should run.
				
					Figure 5-1: The contents of the /boot directory, with config.txt highlighted
				
				
				If you’re having problems with graphics output, such as the image not filling the screen or spilling over the edge, config.txt is where you’ll be able to fix it. Normally, the file is empty or—on some distributions—simply not present; this just means that the Pi will operate using its preset defaults. If you want to make changes and the file isn’t there, just create a new text file called config.txt and fill in the settings you want to change.
				The config.txt file can control almost all aspects of the Pi’s hardware, with the exception of the way the central processing unit (CPU) and graphics processing unit (GPU) sections of the BCM2835 apportion the memory. You’ll learn how to alter that split in the “Memory Partitioning—start.elf" section, later in this chapter.
				The config.txt file is only read when the system first starts up. Any changes made while the Pi is running won’t take effect until the system is restarted, or switched off and back on again. In the event that the changes are unwanted, simply deleting the file from the /boot directory should be enough to restore the defaults once more. If the Pi won’t boot with your new settings, just remove the SD card and delete config.txt from the boot partition on another PC, and then reinsert it into the Pi and try again.
				Modifying the Display
				Usually, the Raspberry Pi will detect the type of display that’s connected and alter its settings accordingly. Sometimes, however, this automatic detection doesn’t work. This is often the case when a Raspberry Pi from one country is connected to an older TV from another country. If you connect your Pi to your TV and there’s nothing to see, you may need to override these defaults.
				Various settings in the config.txt file can be used to improve or alter the video output. These settings, and their possible values, are described in the following list.
				
				Manually adjusting the HDMI or composite video output settings can leave your Pi unable to communicate with your monitor. It’s usually best to use the automatically-detected settings, unless you’re unable to see a picture in the first place.
				overscan_left—This moves the picture inwards a set number of pixels to compensate for a TV’s overscan. If the text on the Pi is disappearing off the edge of the screen, adjusting the overscan will fix it. Values should be given as the number of pixels to skip.
				overscan_right—This does the same job as overscan_left, but on the right side of the screen.
				overscan_top—Again, this ignores a certain number of pixels, but this time on the top of the screen.
				overscan_bottom—This can be used to skip a number of pixels from the bottom of the display. Typically, the values for all the overscan_ settings would be the same, creating a regular border around the display.
				disable_overscan—If you use a monitor or TV via HDMI, you may find that your image has a black border around it. To get rid of this border, any default overscan settings can be disabled by setting this value to 1.
				framebuffer_width—This value is measured in pixels, and adjusting it will change the width of the console. If text appears too small on your screen, try changing this to a lower value than the default width of the connected display.
				framebuffer_height—This affects the size of the console in the same way as framebuffer_width, but vertically rather than horizontally.
				framebuffer_depth—Controls the colour depth of the console in bits per pixel. The default is 16 bits per pixel, which gives 65,536 colours. Other values, including 8 bits per pixel (256 colours), 24 bits per pixel (around 16.7 million colours) and 32 bits per pixel (around 1 billion colours) are valid, but may cause graphical corruption.
				framebuffer_ignore_alpha—Set to 1, this value disables the alpha channel, which controls transparency in the console. Disabling the alpha channel is not normally required, but may correct graphical corruption caused when setting framebuffer_depth to 32 bits per pixel.
				sdtv_mode—This value affects the analogue composite video output of the Pi, adjusting it to operate in various countries. By default, the Pi uses the North American version of the NTSC video standard; users in other countries may need to change this value to get a picture on an analogue TV. Possible values are:
				•	0—NTSC, the North American video standard
				•	1—NTSC-J, the Japanese video standard
				•	2—PAL, the video standard for the UK and other countries
				•	3—PAL-M, the Brazilian video standard
				sdtv_aspect—Controls the aspect ratio of the analogue composite output. If the picture looks stretched or squished, alter this to correspond to your TV’s aspect ratio. Possible values are:
				•	1—4:3 aspect ratio, common on older sets
				•	2—14:9 aspect ratio, common for smaller widescreen TVs
				•	3—16:9 aspect ratio, common for modern widescreen TVs
				hdmi_mode—In addition to setting the video mode for the analogue composite output, it’s also possible to override automatic resolution detection on the HDMI port. This is handy if you want to run your Pi at a lower resolution than the display’s native resolution in order to make things more readable from a distance. Refer to the appendix, “HDMI Display Modes", for a list of possible values for this setting.
				hdmi_drive—It’s also possible to alter the voltage output by the HDMI port. This is important when you’re using an HDMI to DVI adapter, because HDMI and DVI voltages differ slightly. If you find that your picture is snowy or blown out with too bright an image, try altering this setting. Possible values are:
				•	1—DVI output voltages. In this mode, no audio is included on the HDMI cable.
				•	2—HDMI output voltages. In this mode, audio is included on the HDMI cable.
				hdmi_force_hotplug—Forces the Raspberry Pi to use the HDMI port, even if it doesn’t detect a connected display. A value of 0 allows the Pi to attempt to detect the display, while a value of 1 forces the Pi to use HDMI regardless.
				hdmi_group—Sets the HDMI group mode to CEA or DMT. You should change this setting according to the display type you’re trying to connect, before using hdmi_mode to control the output resolution and frequency. The two possible values are:
				•	1—Sets the HDMI group to that defined by the Consumer Electronics Association of America (CEA). Use this setting when the Pi is connected to a high-definition television (HDTV) over HDMI and use the first settings list from the appendix, “HDMI Display Modes".
				•	2—Sets the HDMI group to that defined by the Video Electronics Standards Association (VESA) in the Display Monitor Timings (DMT) specification. Use this setting when the Pi is connected to a computer monitor over DVI and use the second settings list from the appendix, “HDMI Display Modes".
				hdmi_safe—Forces the Pi to use a pre-set collection of HDMI settings designed to provide maximum compatibility with displays connected to the HDMI port. Setting this to a value of 1 is the equivalent of setting hdmi_force_hotpug=1, config_hdmi_boost=4, hdmi_group=1, hdmi_mode=1 and disable_overscan=0.
				config_hdmi_boost—Some monitors require more power on the HDMI output to operate. If your picture is covered in snow, try increasing this value in stages from 1 (for short cables) to 7 (for long cables.)
				Each option in config.txt should be on its own line, with the option name followed by an equals sign (=) and then the required value. For example, to tell the Pi to use a PAL-format analogue TV with a 4:3 aspect ratio and a 20-pixel overscan on all sides, put the following lines into config.txt:
				sdtv_mode=2
				sdtv_aspect=1
				overscan_left=20
				overscan_right=20
				overscan_top=20
				overscan_bottom=20
				To tell the Pi to use a DVI display through the HDMI port in the 720p60 format with no overscan at all, use the following values instead:
				hdmi_group=1
				hdmi_mode=4
				hdmi_drive=1
				disable_overscan=1
				For the changes to take effect, the Pi must be restarted. If you find that your changes have disabled the Pi’s video output on your monitor, simply insert the SD card into another computer and either modify the config.txt file with new settings or delete it altogether to restore the defaults.
				Boot Options
				The config.txt file can also be used to control how Linux is loaded on the Raspberry Pi. Although the most common method for controlling the loading of the Linux kernel is to use a separate file called cmdline.txt (which you’ll learn about later in this chapter), it is possible to use just config.txt. The following options control the boot process:
				disable_commandline_tags—This tells the start.elf module (discussed later in this chapter) to skip filling in memory locations past 0x100 before loading the Linux kernel. This option should not be disabled, as doing so can cause Linux to load incorrectly and crash.
				cmdline—The command line parameters to be passed to the Linux kernel. This can be used in place of the cmdline.txt file, usually found in the /boot directory.
				kernel—The name of the kernel file to be loaded. This can be used as a way to load the emergency kernel (see Chapter 3, “Troubleshooting").
				ramfsfile—The name of the initial RAM file system (RAMFS) to be loaded. This should rarely be modified, unless you’ve built a new initial file system with which to experiment.
				init_uart_baud—The speed of the serial console, in bits per second. The default is 115200, but lower values may improve the connection if the Pi is used with an older hardware serial terminal.
				Overclocking the Raspberry Pi
				The config.txt file not only controls the graphics outputs of the Pi’s BCM2835 processor, but it also enables you to control the chip in other ways as well. In particular, it allows you to alter the speed at which the chip runs, increasing its performance at the expense of the part’s lifespan—a process known as overclocking.
				
				Adjusting any of the settings listed in this section can result in damage to your Pi. In particular, changing settings corresponding to memory, GPU or CPU voltages will set a fuse in the chip, which invalidates the Raspberry Pi’s warranty even if the setting is returned back to normal before any damage is done. Damage caused when using these settings will not be put right by the Raspberry Pi Foundation or by the retailer from whom you purchased your Pi. If in doubt, don’t alter these settings: the performance gains through overclocking are rarely worth the risk to the Pi.
				The BCM2835 multimedia processor at the heart of the Pi is a system-on-chip (SoC) design split into two main parts: the graphics processor (GPU) and the central processor (CPU). Simply put, the CPU handles all the day-to-day processing tasks while the GPU handles drawing things on the screen, in both 2D and 3D.
				Using config.txt, you can overclock one or both parts of the BCM2835. You can also increase the speed at which the memory module—located on top of the chip in a package-on-package (PoP) mounting format—operates.
				Boosting the operating frequency of these components results in a small increase in the Pi’s performance: an increase to the GPU’s clock frequency means that 3D graphics (such as game graphics) will render at a faster pace, and video will be decoded quicker for smoother playback; and increasing the CPU’s clock frequency will boost overall performance of the device, as will increasing the memory’s frequency.
				The reason the Pi isn’t provided with higher operating speeds in the first place is related to the chips’ lifespan. The BCM2835 is rated by its manufacturer, Broadcom, to operate at a speed of 700 MHz. Increasing the speed above this officially-rated level may work, but it will also have a deleterious effect on the lifespan of the chip. Unlike a desktop processor, SoC designs rarely have much headroom for overclocking.
				Overclocking Settings
				If you’re willing to take the risk of breaking the Pi—a process known as bricking in embedded device circles—for the sake of a small performance gain, there are settings in config.txt which can help. The following settings control performance of the Pi’s SoC: 
				arm_freq—Sets the core clock frequency of the CPU portion of the BCM2835, for a boost in general-purpose performance. The default speed is 700 MHz.
				gpu_freq—Sets the clock frequency of the GPU portion of the BCM2835, for a boost in graphics performance across all operations. The default speed is 250 MHz. Additionally, you can adjust individual portions of the GPU’s hardware using the following options:
				•	core_freq—Sets the core clock frequency of the GPU, leaving the other frequencies alone, to improve overall GPU performance. The default speed is 250 MHz.
				•	h264_freq—Sets the clock frequency of the GPU’s hardware video decoder to improve playback of H.264 video data. The default speed is 250 MHz.
				•	isp_freq—Sets the clock frequency of the image sensor pipeline, for improving the capture rate of connected video hardware (such as a camera). The default speed is 250 MHz.
				•	v3d_freq—Sets the clock frequency of the GPU’s 3D rendering hardware, for a boost in visualisation and gaming performance. The default speed is 250 MHz.
				sdram_freq—Sets the clock speed of the random access memory (RAM) chip on the Pi, to give the entire system a small increase in performance. The default speed is 400 MHz.
				init_uart_clock—Sets the default clock speed of the Universal Asynchronous Receiver/Transmitter (UART), used to control the serial console. The default is 3000000, which sets a speed of 3 MHz. Altering this is likely to have little effect beyond corrupting the output of the serial console.
				init_emmc_clock—Sets the default clock speed of the SD card controller. The default is 80000000, which sets a speed of 80 MHz. Increasing this value can result in faster reading and writing from the SD card, but can also lead to data corruption.
				As an example, to overclock the CPU to 800 MHz, the GPU to 280 MHz and the RAM to 420 MHz, enter the following options into config.txt, one per line:
				arm_freq=800
				gpu_freq=280
				sdram_freq=420
				As with adjusting the display configuration, any changes made regarding overclocking won’t take effect until the Pi is restarted. To return the settings to normal, you can either delete the entire config.txt file or—if you’re using it to control the display settings as well—simply delete the lines that deal with overclocking, and then restart the Pi.
				Overvoltage Settings
				If you’re overclocking your Pi, you will eventually hit a brick wall past which the device won’t go. The precise point at which the Pi won’t reliably overclock depends on the individual device, due to natural variations in the chip introduced during the manufacturing stage. For some users, this limit may be as low as 800 MHz; others may find that they can push their Pi as high as 1 GHz (1,000 MHz) without issue.
				If you want to eke a little more performance out of your Pi, there is a way to potentially boost this upper limit: a process known as overvoltage or overvolting. The Pi’s BCM2835 system-on-chip processor and the associated memory module usually run at 1.2 volts. It’s possible, although potentially inadvisable, to override this default and force the components to run at higher or lower voltages. Boosting the voltage means boosting the signal within the chip, making it more likely to hit higher speeds—it also means that the chip runs hotter, reducing its lifespan dramatically compared to overclocking alone.
				
				Setting any of the voltage options in config.txt causes a fuse within the BCM2835 to trip in a way that cannot be reset. It’s a foolproof way to tell if someone has been attempting to overclock the chip outside its rated specifications, and renders your warranty null and void—even if the cause of failure is unrelated to overclocking. If you return a Pi for replacement under warranty and the fuse is tripped, it will not be replaced. Do not attempt to overvolt a Pi that you cannot afford to replace yourself.
				Unlike the previously described settings, which are provided in config.txt as absolute values, the voltage adjustment is carried out using values relative to the Pi’s stock 1.2 V setting. For each whole number above zero, the voltage is increased by 0.025 V from stock. For each whole number below zero, the voltage is decreased by 0.025 V from stock.
				The voltage adjustment settings have upper and lower limits of 8 and -16, equivalent to 0.2 V above stock voltage or 1.4 V absolute and 0.4 V below stock voltage or 0.8 V absolute. The voltage must be adjusted in whole numbers, and it cannot be adjusted below 0.8 V (-16) or above 1.4 V (8.)
				The following settings are accessible from config.txt:
				over_voltage—Adjusts the BCM2835’s core voltage. Values are given as a whole number (an integer) corresponding to 0.025 V above or below the default value (0,) with a lower limit of -16 and an upper limit of 8.
				over_voltage_sdram—Adjusts the voltage given to the memory chip on the Pi. As with over_voltage, values are given as a whole number corresponding to 0.025 V above or below the stock (0,) with a lower limit of -16 and an upper limit of 8. Additionally, you can adjust voltages for individual memory components using the following options:
				•	over_voltage_sdram_c—Adjusts the voltage given to the memory controller. Acceptable values are the same as with over_voltage_sdram.
				•	over_voltage_sdram_i—Adjusts the voltage given to the memory’s input/output (I/O) system. Acceptable values are the same as with over_voltage_sdram.
				•	over_voltage_sdram_p—Adjusts the voltage given to the memory’s physical layer (PHY) components. Acceptable values are the same as with over_voltage_sdram.
				As an example, the following lines entered into config.txt will give the BCM2835 a small boost of 0.05 V to 1.25 V and the memory chip a bigger boost of 0.1 V to 1.3 V:
				over_voltage=2
				over_voltage_sdram=4
				As with other settings, deleting the lines from config.txt or deleting the file itself will return things to normal. Unlike the other settings in this section, however, the evidence will remain in the form of a blown fuse in the BCM2835—rendering the Pi’s warranty null and void even after the default settings are restored.
				Disabling L2 Cache
				The Pi’s BCM2835 SoC processor has 128 KB of Layer 2 cache memory onboard. Although this memory is small, it’s extremely fast. It’s used to temporarily store—aka cache—data and instructions between the slower main memory and the processor itself to improve performance.
				Because of the BCM2835’s origins as a multimedia processor targeted at set-top boxes, this L2 cache is designed to be used by the GPU portion of the chip alone. Unlike a traditional processor, the CPU doesn’t have any L2 cache of its own.
				Using config.txt, you can tell the BCM2835 to allow its CPU portion access to the L2 cache memory. In some cases, this can improve performance. In other cases, this can harm performance, due to the physical location of the cache being a relatively long distance away from the CPU section of the chip and closer to the GPU.
				Use of the L2 cache memory also requires a Linux distribution that has been compiled with the cache memory in mind. Enabling the L2 cache on a distribution built for a standard Pi with cache disabled may result in strange and unwanted behaviour.
				To switch the L2 cache on for CPU access, simply add the following line to the config.txt file:
				disable_l2cache=0
				As with all config.txt settings, the system must be rebooted before the change will take place. To disable the CPU’s access to the cache memory, replace the 0 with a 1.
				Enabling Test Mode
				This final option in config.txt is one the overwhelming majority of Pi users won’t need to touch, but is included here for completeness: test mode. Used during production of the Raspberry Pi at the factory, the test mode—combined with special hardware used to electrically check the board—allows the factory staff to make sure the Pi is operating as it should.
				
				Enabling test mode won’t do any permanent damage, but the Pi won’t boot into its operating system until the mode is disabled again and the power to the Pi is switched off and back on.
				If you’re curious to see what the Pi looks like to factory staff, you can enable test mode by entering the following option into the config.txt file:
				test_mode=1
				As with other config.txt settings, test mode won’t be enabled until the Pi is restarted. Test mode can be disabled again by removing the line in config.txt, deleting the file altogether, or replacing the 1 with a 0.
				Memory Partitioning—start.elf
				Although the Raspberry Pi only has a single 256 MB memory chip, that memory can be apportioned to the hardware in a variety of ways. The BCM2835 is split into two main sections: the general-purpose CPU and the graphics-oriented GPU. Both of these sections require memory to operate, meaning that the 256 MB of memory on the Raspberry Pi needs to be shared between the two. This split is controlled by a file called start.elf.
				The typical split is chosen by the maintainers of the Linux distribution installed on the Pi. Some choose to split the memory straight down the middle, at 128 MB each for CPU and GPU, ensuring that the graphics hardware can perform to its fullest potential. Others allow the CPU to have a larger share in order to improve general-purpose performance.
				The majority of distributions include three copies of start.elf in addition to the one that’s loaded when the Pi boots: arm128_start.elf, arm192_start.elf, and arm224_start.elf (see Figure 5-2). These three files are identical except for one small change: the amount of memory reserved for the BCM2835’s CPU.
				
					Figure 5-2: The various start.elf files in the /boot directory
				
				
				The first file, arm128_start.elf, is configured to split the memory down the middle, with 128 MB available to the BCM2835’s ARM CPU and 128 MB available to the VideoCore IV GPU.
				The second and third files gradually reduce the amount of memory available to the GPU. arm192_start.elf gives 192 MB to the CPU and 64 MB to the GPU, while arm224_start.elf gives 224 MB to the CPU and 32 MB to the GPU. By telling the Pi to use these files, you can increase the amount of memory available for general-purpose computing.
				
				Applications that do heavy graphics work, such as 3D games and high-definition video playback software, typically need 128 MB of memory for the GPU. Reducing this can result in a dramatic drop in performance. 
				Most general-purpose distributions work on a 192 MB/64 MB split, but you can free up more memory for programs by forcing the Pi to use the 224 MB/32 MB split. This can improve general-purpose performance without the risks associated with overclocking the Pi.
				To change how the memory is apportioned, simply delete start.elf from the /boot directory and copy one of the three other versions in its place. Make sure you rename the file to start.elf, or the Pi won’t boot. The easiest way to achieve this is to type the following at the terminal:
				sudo cp /boot/arm224_start.elf /boot/start.elf
				When you next reboot the Pi, it will have more memory available to the ARM CPU. To check the amount of memory available, type free at the terminal. To change to another memory split, simply repeat the preceding command with a different version of start.elf as the source file: arm_192_start.elf or arm128_start.elf.
				Software Settings—cmdline.txt
				In addition to config.txt, which controls various features of the Pi’s hardware, there’s another important text file in the /boot directory: cmdline.txt (see Figure 5-3). This file contains what is known as the kernel mode line—options passed to the Linux kernel as the Pi boots up.
				
					Figure 5-3: The cmdline.txt file in /boot
				
				
				In a Linux-based desktop or laptop, these options are normally passed to the kernel by a tool known as a bootloader, which has its own configuration file. On the Pi, the options are simply entered directly into cmdline.txt to be read by the Pi at startup.
				Almost any kernel option supported by Linux can be entered into the cmdline.txt file, to alter things like the appearance of the console or which kernel is loaded. As an example, here is the cmdline.txt file from the Debian distribution:
				dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait
				The first option, dwg_otc.lpm_enable, tells the Pi to disable the On-The-Go (OTG) mode of its USB controller, to prevent problems that can occur when the functionality is enabled without proper support in the operating system. The majority of Linux distributions for the Pi disable this mode.
				The console option tells Linux that it should create a serial console—device ttyAMA0—and at what speed it should operate. In most cases, the speed should be left at the default of 115,200 Kb/s (kilobytes per second). If the Pi is being used to communicate with older devices, this can be reduced accordingly.
				The kgdboc kernel option enables debugging of the Linux kernel over the serial console created using the console parameter. For most users, this is unnecessary. For developers, having access to kernel debugging over a serial connection is most useful. Many distributions leave this enabled just in case.
				The second console entry creates the device tty1, which is the text-filled screen you see when you first boot the Pi. Without this entry, you wouldn’t be able to use the Pi without connecting something to the serial console created by the first console option.
				The root option tells the Linux kernel where it can find its root file system, containing all the files and directories required for the system to operate. In the case of the default Debian distribution, this is on the second partition of the SD card—device mmcblk0p2. This option can be altered to address an external storage device connected over USB, which can speed up the operation of the Pi considerably compared to having the root file system stored on the SD card. 
				In addition to telling the kernel where to find its root file system, it also needs to know what format the partition was created in. Because Linux supports a variety of different file systems, the rootfstype option specifically tells the Debian distribution uses an EXT4 file system.
				Finally, the rootwait parameter tells the kernel that it should not try to boot the system any further until the device containing the root file system is available. Without this option, the Pi can get stuck as it begins to boot before the relatively slow SD card is fully ready for access.
				With the exception of the dwc_otg setting, none of these kernel parameters are unique to the Pi. The bootloader configuration of any Linux distribution will include a list of options very similar to those of cmdline.txt.
				Typically, you should leave the cmdline.txt alone. It’s created by the distribution maintainers specifically for that version of Linux, and may differ from one distribution to the next. Entries that work on Fedora Remix may not work on Debian, and vice versa. The options available to cmdline.txt depend on what kernel the distribution is using and what features were included when the kernel was built.
				If you’re a kernel developer, you can use cmdline.txt to pass parameters for enabling or disabling new functionality that you’ve compiled into the kernel. As with config.txt, any changes require a reboot to take effect.
				
				
			
		
	




	
		9781118494684-ch06.g.html
		
	
	
		
			
				Chapter 6
				The GPIO Port
				The Raspberry Pi’s GPIO port is located on the top-left of the printed circuit board, labelled P1. It’s a 26-pin port, fitted with two rows of 13 male 2.54 mm headers at the factory. The spacing of these headers is particularly important: 2.54 mm pin spacing (0.1 inches in imperial measurements) is a very common sight in electronics, and is the standard spacing for prototyping platforms that include stripboards and breadboards.
				Each pin of the GPIO port has its own purpose, with several pins working together to form particular circuits. The layout of the GPIO port can be seen in Figure 6-1.
				
					Figure 6-1: The Raspberry Pi’s GPIO port and its pin definitions
				
				
				Pin numbers for the GPIO port are split into two rows, with the bottom row taking the odd numbers and the top row the even numbers. It’s important to keep this in mind when working with the Pi’s GPIO port: most other devices use a different system for numbering pins, and because there are no markings on the Pi itself, it’s easy to get confused as to which pin is which.
				
				Never connect anything to the pins marked Do Not Connect; these are reserved for internal functions of the Pi’s BCM2835 system-on-chip (SoC) hardware. Connecting anything to these will result in damage to the Pi.
				Although the Pi’s GPIO port provides a 5 V power supply, tapped from the incoming power on the micro-USB hub, on Pin 2, the Pi’s internal workings are based on 3.3 V logic. This means that the components on the Pi work from a 3.3 V power supply. If you’re planning on creating a circuit that will interface with the Pi through its GPIO port, make sure you are using components compatible with 3.3 V logic or are passing the circuit through a voltage regulator before it reaches the Pi.
				
				Connecting a 5 V supply to any pin on the Raspberry Pi’s GPIO port, or shorting either of the power supply pins (Pin 1 and Pin 2) to any port except Ground (Pin 6) will result in damage to the Pi. Because the port is wired directly to pins on the Broadcom BCM2835 SoC processor, you will not be able to repair any damage you do to it. Always be extra careful when working around the GPIO port.
				The GPIO port provides seven pins for general-purpose use by default: Pin 11, Pin 12, Pin 13, Pin 15, Pin 16, Pin 18 and Pin 22. Additionally, Pin 7—while defaulting to providing a clock signal for general purpose use—can also be used as a general-purpose pin, giving eight pins in total. These pins can be toggled between two states: high, where they are providing a positive voltage of 3.3 V; and low, where they are equal to ground or 0 V. This equates to the 1 and 0 of binary logic, and can be used to turn other components on or off. You’ll learn more about this later in the chapter.
				
				The Pi’s internal logic operates at 3.3 V. This is in contrast to many common microcontroller devices, such as the popular Arduino and its variants, which typically operate at 5 V. Devices designed for the Arduino may not work with the Pi unless a level translator or optical isolator is used between the two. Likewise, connecting pins on a 5 V microcontroller directly to the Raspberry Pi’s GPIO port will not work and may permanently damage the Pi.
				GPIO Port Buses
				In addition to its general-purpose pins, the GPIO port has a number of pins dedicated to particular buses. These buses are described in the following subsections.
				UART Serial Bus
				The Universal Asynchronous Receiver/Transmitter (UART) serial bus provides a simple two-wire serial interface. When a serial port is configured in the cmdline.txt file (as described in Chapter 5, “Configuring the Raspberry Pi"), it’s this serial bus that is used as the port for the messages. Connecting the Pi’s UART serial bus to a device capable of displaying the data will reveal messages from the Linux kernel. If you’re having trouble getting the Pi to boot, this can be a handy diagnostic tool—especially if nothing is showing on the display.
				The UART serial bus can be accessed on Pins 8 and 10, with Pin 8 carrying the transmit signal and Pin 8 carrying the receive signal. The speed can be set in the cmdline.txt file, and is usually 115,200 bits per second (bps).
				I²C Bus
				As the name suggests, the Inter-Integrated Circuit (I²C) bus is designed to provide communications between two different integrated circuits (ICs). In the case of the Pi, one of those integrated circuits is the Broadcom BCM2835 SoC processor at the heart of the system. These pins include access to pull-up resistors located on the Pi, meaning no external resistors are required to access the I²C functionality.
				The I²C bus can be accessed on Pins 3 and 4, with Pin 3 providing the Serial Data Line (SDA) signal and Pin 4 providing the Serial Clock (SCL) signal. The I²C bus available on these pins is actually only one of two provided by the BCM2835 chip itself, and is known as I²C0. The second, I²C1, is terminated at resistors on the Raspberry Pi circuit board itself and is not available for general-purpose use.
				SPI Bus
				The Serial Peripheral Interface (SPI) bus is a synchronous serial bus designed primarily for in-system programming (ISP) of microcontrollers and other devices. Unlike the UART and I²C buses, it’s a four-wire bus with multiple Chip Select lines which allow it to communicate with more than one target device.
				The Pi’s SPI bus is available on Pins 19, 21 and 23, with a pair of Chip Select lines on Pin 24 and Pin 26. Pin 19 provides the SPI Master Output, Slave Input (MOSI) signal; Pin 21 provides the SPI Master Input, Slave Output (MISO) signal; Pin 23 provides the Serial Clock (SLCK) used to synchronise communication; and Pins 24 and 26 provide the Chip Select signals for up to two independent slave devices.
				Although additional buses are present in the Raspberry Pi’s BCM2835 SoC processor, they are not brought out to the GPIO port and are thus unavailable for use.
				Using the GPIO Port in Python
				With the theory out of the way, it’s time to get practical. In this section, you’ll learn how to install a library to allow easy access to the general-purpose pins on the Raspberry Pi’s GPIO port in Python. You’ll also be shown two simple electronic circuits which demonstrate how to use the GPIO port for input and output.
				Python is a friendly yet powerful programming language. It’s not, however, the perfect choice for every scenario. Although it works fine for the simple circuits you’ll be creating in this chapter, it does not offer what is known as deterministic real-time operation. For the majority of users, this doesn’t matter; if you’re planning on using the Pi at the heart of a nuclear reactor or a complex robotics platform, however, you may want to investigate a lower-level language such as C++ or even assembler running on a dedicated real-time microcontroller.
				If true real-time operation is required for your project, the Pi may be a bad choice. Instead, consider using a microcontroller platform such as the popular open-source Arduino, or one of the MSP430 family of microcontrollers from Texas Instruments. Both of these devices can interface with the Pi either through the GPIO header or over USB, and provide a specialised real-time environment for control and sensing.
				Installing the GPIO Python Library
				Since the launch of the Pi, numerous developers have created software modules known as libraries for making full use of its various functions. In particular, programmers have addressed the Pi users’ need to access the GPIO port without having to know low-level programming.
				These libraries are designed to extend the functionality of the base Python language. Installing one of these libraries gives Python the ability to easily address the Pi’s GPIO port, although it means that anyone planning to use the software you create will also have to download and install the library before it will work.
				There are several GPIO Python libraries available, but for the purpose of this section, we recommend that you use the raspberry-gpio-python library, which was at version 0.2.0 at the time of writing. You can access this library from the Google Code website at the following address: http://code.google.com/p/raspberry-gpio-python/
				Although it’s possible to download the Python library through a web browser, it’s significantly quicker to do so through the terminal as part of the installation process. Just follow these steps:
					1.	Open a terminal window on your Raspberry Pi from the Accessories menu, or use the console if you haven’t loaded a desktop environment.
					2.	Type wget http://raspberry-gpio-python.googlecode.com/files/RPi.GPIO-0.2.0.tar.gz to download the library to your home directory. If a newer version has been released, replace the version number—0.2.0—with the current version.
					3.	Type tar xvzf RPi.GPIO-0.2.0.tar.gz to extract the contents of the file. This command is case-sensitive, so make sure to type the capital letters.
					4.	Type cd RPi.GPIO-0.2.0 to change to the newly created directory. Again, if you downloaded a newer version of the library, replace the version number with that of the downloaded version.
					5.	Type sudo python setup.py install to install the library into Python.
				Although the GPIO library is now installed in Python, it won’t be loaded by default. Like pygame, the library needs to be explicitly imported into your program. To use the library, start your program with import RPi.GPIO as GPIO at the top. You’ll learn more about this in the following examples.
				
				The Raspberry Pi’s GPIO port does not provide any protection against voltage spikes or electrical shorts. Always make sure you’ve checked that your circuit is sound before connecting it to the Pi. If possible, use an isolation board such as the Gertboard to provide protection.
				GPIO Output: Flashing an LED
				For the first example, you’ll need to build a simple circuit consisting of an LED and a resistor. The LED will provide visual confirmation that the Pi’s GPIO port is doing what your Python program tells it to do, and the resistor will limit the current drawn by the LED to protect it from burning out.
				
				Calculating Limiting Resistor Values
				An LED needs a current limiting resistor to protect it from burning out. Without a resistor, an LED will likely only work for a short time before failing and needing to be replaced. Knowing a resistor is required is one thing, but it’s also important to pick the right resistor for the job. Too high a value and the LED will be extremely dim or fail to light at all; too low a value and it will burn out.
				To calculate the resistor value required, you will need to know the forward current of your LED. This is the maximum current the LED can draw before being damaged, and is measured in milliamps (mA). You’ll also need to know the forward voltage of the LED. This latter value, measured in volts, should be 3.3 V or lower—any higher, and the LED will require an external power supply and a switching device known as a transistor before it will work with the Pi.
				The easiest way to work out how large a resistor is required is with the formula R=(V-F)/I, where R is resistance in ohms, V is the voltage applied to the LED, F is the forward voltage of the LED and I is the maximum forward current of the LED in amps (with a thousand mA to the amp).
				Taking a typical red LED with a forward current of 25 mA and a forward voltage of 1.7 V, and powering it using the 3.3 V supplied by the Pi’s GPIO port, you can calculate the resistor needed as (3.3 – 1.7) / 0.025 = 64. Thus, a resistor of 64 Ω or higher will protect the LED. These figures rarely come out to match the common resistor values as sold, so when you’re choosing a resistor, always round up to ensure the LED is protected. The nearest commonly available value is 68 Ω, which will adequately protect the LED.
				If you don’t know the forward voltage and forward current of your LEDs (for example, if the LEDs did not come with documentation or were salvaged from scrap electronics), err on the side of caution and fit a reasonably large resistor. If the LED is too dim, you can revise downwards—but it’s impossible to repair an LED that has been blown.
				
				To assemble the circuit, you’ll need a breadboard, two jumper wires, an LED and an appropriate current-limiting resistor (as described in the “Calculating Limiting Resistor Values" sidebar). Although it’s possible to assemble the circuit without a breadboard by twisting wires together, a breadboard is a sound investment and makes assembling and disassembling prototype circuits straightforward.
				Assuming the use of a breadboard, assemble the circuit in the following manner to match Figure 6-2:
					1.	Insert the LED into the breadboard so that the long leg (the anode) is in one row and the shorter leg (the cathode) is in another. If you put the LED’s legs into the same row, it won’t work.
					2.	Insert one leg of the resistor into the same row as the LED’s shorter leg, and the other resistor leg into an empty row. The direction in which the resistor’s legs are placed doesn’t matter, as a resistor is a non-polarised (direction-insensitive) device.
					3.	Using a jumper wire, connect Pin 11 of the Raspberry Pi’s GPIO port (or the corresponding pin on an interface board connected to the GPIO port) to the same row as the long leg of the LED.
					4.	Using another jumper wire, connect Pin 6 of the Raspberry Pi’s GPIO port (or the corresponding pin on an interface board connected to the GPIO port) to the row that contains only one leg of the resistor and none of the LED’s legs.
				
					Figure 6-2: A breadboard circuit for a simple LED output
				
				
				
				Be very careful when connecting wires to the Raspberry Pi’s GPIO port. As discussed earlier in the chapter, you may do serious damage to the Pi if you connect the wrong pins.
				At this point, nothing will happen. That’s perfectly normal: by default, the Raspberry Pi’s GPIO pins are switched off. If you want to check your circuit immediately, move the wire from Pin 11 to Pin 1 to make the LED light up. Be careful not to connect it to Pin 2, though: a current-limiting resistor suitable for a 3.3 V power supply will be inadequate to protect the LED when connected to 5 V. Remember to move the wire back to Pin 11 before continuing.
				To make the LED do something useful, start a new Python project. As with any Python project, you can use a plain text editor or the IDLE software included in the recommended Debian distribution.
				Before you can use the GPIO library you installed earlier in this chapter, you’ll need to import it into your Python project. Accordingly, start the file with the following line:
				import RPi.GPIO as GPIO
				Remember that Python is case-sensitive, so be sure to type RPi.GPIO exactly as it appears. To allow Python to understand the concept of time (in other words, to make the LED blink, rather than just turning it on and off), you’ll also need to import the time module. Add the following line to the project:
				import time
				With the libraries imported, it’s time to address the GPIO ports. The GPIO library makes it easy to address the general-purpose ports through the instructions GPIO.output and GPIO.input, but before you can use them, you’ll need to initialise the pins as either inputs or outputs. In this example, Pin 11 is an output, so add the following line to the project:
				GPIO.setup(11, GPIO.OUT)
				This tells the GPIO library that Pin 11 on the Raspberry Pi’s GPIO port should be set up as an output. If you were controlling additional devices, you could add more GPIO.setup lines into the project. For now, however, one will suffice.
				With the pin configured as an output, you can switch its 3.3 V supply on and off in a simple demonstration of binary logic. The instruction GPIO.output(11, True) will turn the pin on, while GPIO.output(11, False) switches it off again. The pin will remember its last state, so if you only give the command to turn the pin on and then exit your Python program, the pin will remain on until told otherwise.
				Although you could just add GPIO.output(11, True) to the Python project to switch the pin on, it’s more interesting to make it blink. First, add the following line to create an infinite loop in the program:
				while True:
				Next, add the following lines to switch the pin on, wait 2 seconds, and then switch it off again before waiting another 2 seconds. Make sure each line starts with four spaces, to signify that it is part of the infinite while loop:
				GPIO.output(11, True)
				time.sleep(2)
				GPIO.output(11, False)
				time.sleep(2)
				The finished program should look like this (see Figure 6-3):
				import RPi.GPIO as GPIO
				import time
				GPIO.setup(11, GPIO.OUT)
				while True:
				GPIO.output(11, True)
				time.sleep(2)
				GPIO.output(11, False)
				time.sleep(2)
				
					Figure 6-3: The gpiooutput.py program, being edited in nano, and waiting for its final line
				
				
				Save the file as gpiooutput.py. If you’re using a Python development environment such as SPE, don’t try to run the program from within the editor. Most Raspberry Pi Linux distributions restrict the use of the GPIO port to the root user, so the program will need to be run using the command sudo python gpiooutput.py at the terminal to get it started. If all has gone well, you should see the LED begin to blink on and off at regular intervals—and you’ve created your first home-made output device for the Pi.
				If things don’t work, don’t panic. First, check all your connections. The holes in a breadboard are quite small, and it’s easy to think you’ve inserted a component into one row only to find it’s actually in another. Next, check that you’ve connected the circuit to the right pins on the GPIO port—with no labelling on the Pi itself, mistakes are unfortunately easy to make. Finally, double-check your components—if the forward voltage of your LED is higher than 3.3 V or if your current limiting resistor is too large, the LED won’t light up.
				Although this example is basic, it’s a good demonstration of some fundamental concepts. To extend its functionality, the LED could be replaced with a buzzer to make an audible alert, or a servo or motor as part of a robotics platform. The code used to activate and deactivate the GPIO pin can be integrated into other programs, causing an LED to come on when new email arrives or a flag to be raised when a friend has joined an IRC channel.
				GPIO Input: Reading a Button
				Being able to use the GPIO as an output is undeniably useful, but it becomes significantly more so when you can combine that with one or more inputs. In the following example, you’ll see how to connect a push-button switch to another pin on the GPIO port and read its status in Python.
				As with the earlier LED output example, this input example makes use of the Python GPIO library. Assuming that you have this library installed, you can begin to build the circuit. (If you haven’t installed the Python GIO library yet, skip back a few pages and follow the installation instructions.)
				If you’ve already built the GPIO output example, you can either disconnect that from your Pi or leave it connected—this example uses different pins, so both can co-exist quite happily. If you do leave the previous example connected, make sure to use different rows on the breadboard for the new components or you’ll find things don’t work quite as planned.
				Build the circuit as follows:
					1.	Insert the push-button switch into the breadboard. Most switches have either two or four legs. You only need worry about two of the legs in the circuit. If the button has four legs, they’ll be set up in in pairs: check the push-button’s data sheet to find out which legs are paired together.
					2.	Connect a 10 KΩ resistor to the same row as one of the push-button’s legs and an unused row. This is a pull-up resistor, and will provide the Pi with a reference voltage so it knows when the button has been pressed.
					3.	Connect the unused leg of the pull-up resistor to Pin 1 of the Raspberry Pi’s GPIO port. This provides the 3.3 V reference voltage.
					4.	Connect the unused leg of the push-button switch to Pin 6 of the Raspberry Pi’s GPIO port. This provides the ground connection.
					5.	Finally, connect Pin 12 of the Raspberry Pi’s GPIO port to the other leg of the push-button switch in the same row as the 10 KΩ resistor. Your breadboard should now look like Figure 6-4.
				
					Figure 6-4: The example breadboard layout for a simple push-button input
				
				
				The circuit you just built creates a situation whereby the input pin, which in this instance is Pin 12 of the Raspberry Pi’s GPIO port, is constantly high thanks to the pull-up resistor connected to a 3.3 V supply. When the push-button is pressed, the circuit is grounded and becomes low, providing the cue for your Python program to know that the button has been activated.
				You may wonder why the resistor is required at all, and why the switch does not simply connect Pin 12 to Pin 6 or Pin 1 directly. While this is possible, it creates what is known as a floating pin, which is a pin that doesn’t know whether it’s high or low. As a result, the circuit will act as though the button is being pressed even when it isn’t, and may fail to detect the button being pressed even when it is.
				Open a new Python file, either in a text editor or using one of the Python integrated development environments (IDEs) available on the Raspberry Pi. To begin, you will need to import the same GPIO library as in the previous GPIO output example:
				import RPi.GPIO as GPIO
				You don’t need to import the time library, because this example doesn’t need any timing instructions. Instead, you can get right to setting up Pin 12 as an output. This is done in the same way as setting a pin as an input, with just the final part of the instruction changed accordingly:
				GPIO.setup(12, GPIO.IN)
				If you’re not using Pin 12 for this, make sure you change the pin number in the preceding instruction. 
				As with the previous example, the next step is to create an infinite loop that constantly checks the input pin to see if it’s been brought low (in other words, if it’s been pressed. Begin the loop with the following code line:
				while True:
				Reading the status of an input pin is very similar to setting the status of an output pin, with one exception: before you can do anything useful with the resulting value, you’ll need to store it in a variable. The following instruction tells Python to create a new variable called input_value and set it to the current value of Pin 12:
				input_value = GPIO.input(12)
				Although the program could be executed now and work, it doesn’t do anything useful. To make sure you know what’s going on, add the following print instruction to get feedback:
				if input_value == False:
				print(“The button has been pressed.")
				while input_value == False:
				input_value = GPIO.input(12)
				The last two lines—the second while and the second input_value, an embedded loop—are important. Even on the Raspberry Pi’s processor, which is relatively underpowered when compared to high-performance desktop and laptop processors, Python runs very quickly. This embedded loop tells Python to keep checking the status of Pin 12 until it’s no longer low, at which point it knows the button has been released. Without this loop, the program will loop while the button is being pressed—and no matter how quick your reflexes, you’ll see the message printed to the screen multiple times, which is misleading.
				The final program should look like this:
				import RPi.GPIO as GPIO
				GPIO.setup(12, GPIO.IN)
				while True:
				input_value = GPIO.input(12)
				if input_value == False:
				print(“The button has been pressed.")
				 while input_value == False:
				input_value = GPIO.input(12)
				Save the file as gpioinput.py, and then execute it from the terminal with sudo python gpioinput.py. At first, nothing will happen—but if you press the push-button switch, the program will print the message from line six to the terminal (see Figure 6-5). Release the button and press it again, and the message will be repeated.
				
					Figure 6-5: The output of the gpioinput.py program
				
				
				As with the previous input example, this is a deceptively simple program that can be used for many purposes. In addition to being able to read when a switch is pressed, the same code can be used to read when the pins of a separate device—such as a sensor or external microcontroller—have been pulled high or low.
				By extending the code to look for multiple push-buttons, each on an individual GPIO pin, you could even create a simple four-button game controller. For example, you could combine both input and output examples into a single program, which waits for the button to be pushed and then turns on the LED by sending the output pin high. To ensure that you’ve understood the concepts in this section, try creating that combined program now.
				
				
			
		
	




	
		9781118494684-intro.g.html
		
	
	
	Meet the Raspberry Pi
	Eben Upton and Gareth Halfacree
	
	This edition first published 2012
	© 2012 Eben Upton and Gareth Halfacree
	Registered office: John Wiley  Sons Ltd, The Atrium, Southern Gate, Chichester, West Sussex, PO19 8SQ, United Kingdom 
	For details of our global editorial offices, for customer services and for information about how to apply for permission to reuse the copyright material in this book please see our website at www.wiley.com.
	The right of the authors to be identified as the authors of this work has been asserted in accordance with the Copyright, Designs and Patents Act 1988.
	All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording or otherwise, except as permitted by the UK Copyright, Designs and Patents Act 1988, without the prior permission of the publisher.
	Wiley also publishes its books in a variety of electronic formats.  Some content that appears in print may not be available in electronic books.
	Designations used by companies to distinguish their products are often claimed as trademarks. All brand names and product names used in this book are trade names, service marks, trademarks or registered trademarks of their respective owners. The publisher is not associated with any product or vendor mentioned in this book. This publication is designed to provide accurate and authoritative information in regard to the subject matter covered. It is sold on the understanding that the publisher is not engaged in rendering professional services. If professional advice or other expert assistance is required, the services of a competent professional should be sought.
	Trademarks: Wiley and the Wiley logo are trademarks or registered trademarks of John Wiley and Sons, Inc. and/ or its affiliates in the United States and/or other countries, and may not be used without written permission. Raspberry Pi is a trademark of the Raspberry Pi Foundation.  All other trademarks are the property of their respective owners. John Wiley  Sons, Ltd. is not associated with any product or vendor mentioned in the book.
	A catalogue record for this book is available from the British Library.
	ISBN 978-1-118-49468-4 (ebook); ISBN 978-1-118-49469-1 (ebook)
	




	
		9781118494684-intro.g.html
		
	
	
		
			
				Introduction
				Programming is fun. It’s enormous, rewarding, creative fun. You can create gorgeous intricacies, as well as (much more gorgeous, in my opinion) clever, devastatingly quick and deceptively simple-looking routes through, under and over obstacles. You can make stuff that’ll have other people looking on jealously, and that’ll make you feel wonderfully smug all afternoon.
				The beauty of the Raspberry Pi is that it’s just a very tiny general-purpose computer (which may be a little slower than you’re used to for some desktop applications, but much better at some other stuff than a regular PC), so you can do anything you could do with a regular computer with it. In addition, the Rasperry Pi has much more powerful multimedia than most desktop computers and better 3D graphics performance than some modern games consoles, so it’s got potential as a games platform, and we very much hope to see people starting to write games for it. 
				The Raspberry Pi is cheap enough to buy with a few weeks’ pocket money, and you probably already have all the equipment you need to make it work: a TV, an SD card that can come from an old camera, a mobile phone charger, a keyboard and a mouse. It’s small enough to put in a pocket and take to a friend’s house. If something goes wrong, it’s no big deal—you just swap out a new SD card, and your Raspberry Pi is factory-new again. And all the tools, environments and materials that you need to get started on the long, smooth path to learning how to program your Raspberry Pi are right there, waiting for you as soon as you turn it on.
				We think physical computing—building systems using sensors, motors, lights and microcontrollers—is something that gets overlooked in favour of pure software projects in a lot of instances, and it’s a shame, because physical computing is massive fun. To the extent that there’s any children’s computing movement at the moment, it’s a physical computing movement. The LOGO turtles that represented physical computing when we were kids are now fighting robots, quadcopters or parent-sensing bedroom doors, and we love it. However, the lack of General Purpose Input/Output (GPIO) on home PCs is a real handicap for many people getting started with robotics projects. The Raspberry Pi exposes GPIO so you can get to work straight away.
				We get asked a lot where the name “Raspberry Pi" came from. Bits of the name came from different trustees. It’s one of the very few successful bits of design by committee I’ve seen, and to be honest, I hated it at first. (I have since come to love the name, because it works really well—but it took a bit of getting used to since I’d been calling the project the “ABC Micro" in my head for years.) It’s “Raspberry" because there’s a long tradition of fruit names in computer companies (besides the obvious, there are the old Tangerine and Apricot computers— and we like to think of the Acorn as a fruit as well). “Pi" is a mangling of “Python", which we thought early on in development would be the only programming language available on a much less powerful platform than the Raspberry Pi we ended up with. As it happens, we still recommend Python as our favourite language for learning and development, but there is a world of other language options you can explore on the Raspberry Pi too.
				The Raspberry Pi community is one of the things we’re proudest of. We started with a very bare-bones blog at www.raspberrypi.org in May 2011, and put up a forum on the same website shortly after that. That forum now has more than 20,000 members—between them they’ve contributed more than 100,000 posts of wit and wisdom about the Raspberry Pi. If there’s any question, no matter how abstruse, that you want to ask about the Raspberry Pi or about programming in general, someone there will have the answer. 
				There are now hundreds of fan sites out there. There’s also a fan magazine called The MagPi (a free download from www.themagpi.com), which is produced monthly by community members, with type-in listings, lots of articles, project guides, tutorials and more. Type-in games in magazines and books provided an easy route into programming for me—my earliest programming experience with the BBC Micro was modifying a type-in helicopter game to add enemies and pick-ups.
				I keep being surprised by ideas the community comes up with which wouldn’t have crossed my mind in a thousand years: the Australian school meteor-tracking project; the Boreatton Scouts in the UK and their robot, which is controlled via an electroencephalography headset (the world’s first robot controlled by Scouting brain waves); the family who are building a robot vacuum cleaner. And I’m a real space cadet, so reading about the people sending Raspberry Pis into near-earth orbit on rockets and balloons gives me goosebumps.
				We blog something interesting about the device at www.raspberrypi.org at least once every day. Come and join in the conversation!
				--Eben Upton
			
		
	





	Cover










Table of Contents



Meet the Raspberry Pi

Table of Contents
Introduction
Chapter 1: Meet the Raspberry Pi
ARM vs. x86
Windows vs. Linux
Getting Started with the Raspberry Pi
Connecting a Display
Connecting Audio
Connecting a Keyboard and Mouse
Flashing the SD Card
Connecting External Storage
Connecting the Network
Connecting Power
Chapter 2: Linux System Administration
Linux: An Overview
Linux Basics
Introducing Debian
Using External Storage Devices
Creating a New User Account
Installing and Uninstalling Software
Finding Software
Installing Software
Uninstalling Software
Upgrading Software
Chapter 3: Troubleshooting
Keyboard and Mouse Diagnostics
Power Diagnostics
Display Diagnostics
Boot Diagnostics
Network Diagnostics
The Emergency Kernel
Chapter 4: Network Configuration
Wired Networking
Wireless Networking
Chapter 5: Configuring the Raspberry Pi
Hardware Settings—config.txt
Modifying the Display
Boot Options
Overclocking the Raspberry Pi
Disabling L2 Cache
Enabling Test Mode
Memory Partitioning—start.elf
Software Settings—cmdline.txt
Chapter 6: The GPIO Port
GPIO Port Buses
UART Serial Bus
I²C Bus
SPI Bus
Using the GPIO Port in Python
Installing the GPIO Python Library
GPIO Output: Flashing an LED
GPIO Input: Reading a Button
Appendix: HDMI Display Modes



  